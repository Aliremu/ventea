[Prefix="snippetvehicle2::"]
interface BaseVehicle {
    boolean initialize();
    void destroyState();
    void initComponentSequence(boolean addPhysXBeginEndComponents);
    void step(float dt, [Const, Ref] PxVehicleSimulationContext context);
    [Value] attribute BaseVehicleParams baseParams;
    [Value] attribute BaseVehicleState baseState;
    [Value] attribute PxVehicleComponentSequence componentSequence;
    attribute octet componentSequenceSubstepGroupHandle;
};

[Prefix="snippetvehicle2::"]
interface BaseVehicleParams {
    void BaseVehicleParams();
    [Value] BaseVehicleParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid();
    [Value] attribute PxVehicleAxleDescription axleDescription;
    [Value] attribute PxVehicleFrame frame;
    [Value] attribute PxVehicleScale scale;
    [Value] attribute PxVehicleSuspensionStateCalculationParams suspensionStateCalculationParams;
    [Value] attribute PxVehicleBrakeCommandResponseParams[] brakeResponseParams;
    [Value] attribute PxVehicleSteerCommandResponseParams steerResponseParams;
    [Value] attribute PxVehicleAckermannParams[] ackermannParams;
    [Value] attribute PxVehicleSuspensionParams[] suspensionParams;
    [Value] attribute PxVehicleSuspensionComplianceParams[] suspensionComplianceParams;
    [Value] attribute PxVehicleSuspensionForceParams[] suspensionForceParams;
    [Value] attribute PxVehicleAntiRollForceParams[] antiRollForceParams;
    attribute unsigned long nbAntiRollForceParams;
    [Value] attribute PxVehicleTireForceParams[] tireForceParams;
    [Value] attribute PxVehicleWheelParams[] wheelParams;
    [Value] attribute PxVehicleRigidBodyParams rigidBodyParams;
};

[Prefix="snippetvehicle2::"]
interface BaseVehicleState {
    void BaseVehicleState();
    void setToDefault();
    attribute float[] brakeCommandResponseStates;
    attribute float[] steerCommandResponseStates;
    [Value] attribute PxVehicleWheelActuationState[] actuationStates;
    [Value] attribute PxVehicleRoadGeometryState[] roadGeomStates;
    [Value] attribute PxVehicleSuspensionState[] suspensionStates;
    [Value] attribute PxVehicleSuspensionComplianceState[] suspensionComplianceStates;
    [Value] attribute PxVehicleSuspensionForce[] suspensionForces;
    [Value] attribute PxVehicleAntiRollTorque antiRollTorque;
    [Value] attribute PxVehicleTireGripState[] tireGripStates;
    [Value] attribute PxVehicleTireDirectionState[] tireDirectionStates;
    [Value] attribute PxVehicleTireSpeedState[] tireSpeedStates;
    [Value] attribute PxVehicleTireSlipState[] tireSlipStates;
    [Value] attribute PxVehicleTireCamberAngleState[] tireCamberAngleStates;
    [Value] attribute PxVehicleTireStickyState[] tireStickyStates;
    [Value] attribute PxVehicleTireForce[] tireForces;
    [Value] attribute PxVehicleWheelRigidBody1dState[] wheelRigidBody1dStates;
    [Value] attribute PxVehicleWheelLocalPose[] wheelLocalPoses;
    [Value] attribute PxVehicleRigidBodyState rigidBodyState;
};

[Prefix="snippetvehicle2::"]
interface DirectDriveVehicle {
    void DirectDriveVehicle();
    boolean initialize([Ref] PxPhysics physics, [Const, Ref] PxCookingParams params, [Ref] PxMaterial defaultMaterial, optional boolean addPhysXBeginEndComponents);
    void initComponentSequence(boolean addPhysXBeginEndComponents);
    [Value] attribute DirectDrivetrainParams directDriveParams;
    [Value] attribute DirectDrivetrainState directDriveState;
    [Value] attribute PxVehicleDirectDriveTransmissionCommandState transmissionCommandState;
};
DirectDriveVehicle implements PhysXActorVehicle;

[Prefix="snippetvehicle2::"]
interface DirectDrivetrainParams {
    void DirectDrivetrainParams();
    [Value] DirectDrivetrainParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid([Const, Ref] PxVehicleAxleDescription axleDesc);
    [Value] attribute PxVehicleDirectDriveThrottleCommandResponseParams directDriveThrottleResponseParams;
};

[Prefix="snippetvehicle2::"]
interface DirectDrivetrainState {
    void DirectDrivetrainState();
    void setToDefault();
    attribute float[] directDriveThrottleResponseStates;
};

[Prefix="snippetvehicle2::"]
interface EngineDriveVehicle {
    void EngineDriveVehicle();
    boolean initialize([Ref] PxPhysics physics, [Const, Ref] PxCookingParams params, [Ref] PxMaterial defaultMaterial, EngineDriveVehicleEnum differentialType, optional boolean addPhysXBeginEndComponents);
    void initComponentSequence(boolean addPhysXBeginEndComponents);
    [Value] attribute EngineDrivetrainParams engineDriveParams;
    [Value] attribute EngineDrivetrainState engineDriveState;
    [Value] attribute PxVehicleEngineDriveTransmissionCommandState transmissionCommandState;
    [Value] attribute PxVehicleTankDriveTransmissionCommandState tankDriveTransmissionCommandState;
    attribute EngineDriveVehicleEnum differentialType;
};
EngineDriveVehicle implements PhysXActorVehicle;

[Prefix="snippetvehicle2::"]
interface EngineDrivetrainParams {
    void EngineDrivetrainParams();
    [Value] EngineDrivetrainParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid([Const, Ref] PxVehicleAxleDescription axleDesc);
    [Value] attribute PxVehicleAutoboxParams autoboxParams;
    [Value] attribute PxVehicleClutchCommandResponseParams clutchCommandResponseParams;
    [Value] attribute PxVehicleEngineParams engineParams;
    [Value] attribute PxVehicleGearboxParams gearBoxParams;
    [Value] attribute PxVehicleMultiWheelDriveDifferentialParams multiWheelDifferentialParams;
    [Value] attribute PxVehicleFourWheelDriveDifferentialParams fourWheelDifferentialParams;
    [Value] attribute PxVehicleTankDriveDifferentialParams tankDifferentialParams;
    [Value] attribute PxVehicleClutchParams clutchParams;
};

[Prefix="snippetvehicle2::"]
interface EngineDrivetrainState {
    void EngineDrivetrainState();
    void setToDefault();
    [Value] attribute PxVehicleEngineDriveThrottleCommandResponseState throttleCommandResponseState;
    [Value] attribute PxVehicleAutoboxState autoboxState;
    [Value] attribute PxVehicleClutchCommandResponseState clutchCommandResponseState;
    [Value] attribute PxVehicleDifferentialState differentialState;
    [Value] attribute PxVehicleWheelConstraintGroupState wheelConstraintGroupState;
    [Value] attribute PxVehicleEngineState engineState;
    [Value] attribute PxVehicleGearboxState gearboxState;
    [Value] attribute PxVehicleClutchSlipState clutchState;
};

interface NativeArrayHelpers {
    static octet getU8At([Ref] PxU8ConstPtr base, long index);
    static unsigned short getU16At([Ref] PxU16ConstPtr base, long index);
    static unsigned long getU32At([Ref] PxU32ConstPtr base, long index);
    static float getRealAt([Ref] PxRealPtr base, long index);
    [Value] static PxU8Ptr voidToU8Ptr(VoidPtr voidPtr);
    [Value] static PxU16Ptr voidToU16Ptr(VoidPtr voidPtr);
    [Value] static PxU32Ptr voidToU32Ptr(VoidPtr voidPtr);
    [Value] static PxRealPtr voidToRealPtr(VoidPtr voidPtr);
    static PxActor getActorAt(PxActor base, long index);
    static PxBounds3 getBounds3At(PxBounds3 base, long index);
    static PxContactPair getContactPairAt(PxContactPair base, long index);
    static PxContactPairHeader getContactPairHeaderAt(PxContactPairHeader base, long index);
    static PxController getControllerAt(PxController base, long index);
    static PxControllerShapeHit getControllerShapeHitAt(PxControllerShapeHit base, long index);
    static PxControllersHit getControllersHitAt(PxControllersHit base, long index);
    static PxControllerObstacleHit getControllerObstacleHitAt(PxControllerObstacleHit base, long index);
    static PxObstacle getObstacleAt(PxObstacle base, long index);
    static PxShape getShapeAt(PxShape base, long index);
    static PxTriggerPair getTriggerPairAt(PxTriggerPair base, long index);
    static PxVec3 getVec3At(PxVec3 base, long index);
};

interface PassThroughFilterShader {
    unsigned long filterShader(unsigned long attributes0, unsigned long filterData0w0, unsigned long filterData0w1, unsigned long filterData0w2, unsigned long filterData0w3, unsigned long attributes1, unsigned long filterData1w0, unsigned long filterData1w1, unsigned long filterData1w2, unsigned long filterData1w3);
    attribute unsigned long outputPairFlags;
};
PassThroughFilterShader implements PxSimulationFilterShader;

[JSImplementation="PassThroughFilterShader"]
interface PassThroughFilterShaderImpl {
    void PassThroughFilterShaderImpl();
    unsigned long filterShader(unsigned long attributes0, unsigned long filterData0w0, unsigned long filterData0w1, unsigned long filterData0w2, unsigned long filterData0w3, unsigned long attributes1, unsigned long filterData1w0, unsigned long filterData1w1, unsigned long filterData1w2, unsigned long filterData1w3);
};

[Prefix="snippetvehicle2::"]
interface PhysXActorVehicle {
    boolean initialize([Ref] PxPhysics physics, [Const, Ref] PxCookingParams params, [Ref] PxMaterial defaultMaterial);
    [Value] attribute PhysXIntegrationParams physXParams;
    [Value] attribute PhysXIntegrationState physXState;
    [Value] attribute PxVehicleCommandState commandState;
};
PhysXActorVehicle implements BaseVehicle;

[Prefix="snippetvehicle2::"]
interface PhysXIntegrationParams {
    void PhysXIntegrationParams();
    [Value] PhysXIntegrationParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid([Const, Ref] PxVehicleAxleDescription axleDesc);
    void create([Const, Ref] PxVehicleAxleDescription axleDesc, [Const, Ref] PxQueryFilterData roadQueryFilterData, PxQueryFilterCallback roadQueryFilterCallback, PxVehiclePhysXMaterialFriction materialFrictions, unsigned long nbMaterialFrictions, float defaultFriction, [Const, Ref] PxTransform physxActorCMassLocalPose, [Ref] PxGeometry actorGeometry, [Const, Ref] PxTransform physxActorBoxShapeLocalPose, PxVehiclePhysXRoadGeometryQueryTypeEnum roadGeometryQueryType);
    [Value] attribute PxVehiclePhysXRoadGeometryQueryParams physxRoadGeometryQueryParams;
    [Value] attribute PxVehiclePhysXMaterialFrictionParams[] physxMaterialFrictionParams;
    [Value] attribute PxVehiclePhysXSuspensionLimitConstraintParams[] physxSuspensionLimitConstraintParams;
    [Value] attribute PxTransform physxActorCMassLocalPose;
    attribute PxGeometry physxActorGeometry;
    [Value] attribute PxTransform physxActorBoxShapeLocalPose;
    [Value] attribute PxTransform[] physxWheelShapeLocalPoses;
    [Value] attribute PxShapeFlags physxActorShapeFlags;
    [Value] attribute PxFilterData physxActorSimulationFilterData;
    [Value] attribute PxFilterData physxActorQueryFilterData;
    [Value] attribute PxShapeFlags physxActorWheelShapeFlags;
    [Value] attribute PxFilterData physxActorWheelSimulationFilterData;
    [Value] attribute PxFilterData physxActorWheelQueryFilterData;
};

[Prefix="snippetvehicle2::"]
interface PhysXIntegrationState {
    void PhysXIntegrationState();
    void destroyState();
    void setToDefault();
    void create([Const, Ref] BaseVehicleParams baseParams, [Const, Ref] PhysXIntegrationParams physxParams, [Ref] PxPhysics physics, [Const, Ref] PxCookingParams params, [Ref] PxMaterial defaultMaterial);
    [Value] attribute PxVehiclePhysXActor physxActor;
    [Value] attribute PxVehiclePhysXSteerState physxSteerState;
    [Value] attribute PxVehiclePhysXConstraints physxConstraints;
};

[Prefix="physx::", NoDelete]
interface PxActor {
    PxActorTypeEnum getType();
    PxScene getScene();
    void setName([Const] DOMString name);
    [Const] DOMString getName();
    [Value] PxBounds3 getWorldBounds(optional float inflation);
    void setActorFlag(PxActorFlagEnum flag, boolean value);
    void setActorFlags([Ref] PxActorFlags flags);
    [Value] PxActorFlags getActorFlags();
    void setDominanceGroup(octet dominanceGroup);
    octet getDominanceGroup();
    void setOwnerClient(octet inClient);
    octet getOwnerClient();
    attribute VoidPtr userData;
};
PxActor implements PxBase;

[Prefix="physx::"]
interface PxActorFlags {
    void PxActorFlags(octet flags);
    boolean isSet(PxActorFlagEnum flag);
    void raise(PxActorFlagEnum flag);
    void clear(PxActorFlagEnum flag);
};

interface PxActorPtr {
};

[Prefix="physx::"]
interface PxActorTypeFlags {
    void PxActorTypeFlags(unsigned short flags);
    boolean isSet(PxActorTypeFlagEnum flag);
    void raise(PxActorTypeFlagEnum flag);
    void clear(PxActorTypeFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxAggregate {
    boolean addActor([Ref] PxActor actor, [Const] optional PxBVHStructure bvhStructure);
    boolean removeActor([Ref] PxActor actor);
    unsigned long getNbActors();
    unsigned long getMaxNbActors();
    PxScene getScene();
    boolean getSelfCollision();
};
PxAggregate implements PxBase;

[Prefix="physx::"]
interface PxArticulationAttachment {
    void setRestLength(float restLength);
    float getRestLength();
    void setLimitParameters([Const, Ref] PxArticulationTendonLimit parameters);
    [Value] PxArticulationTendonLimit getLimitParameters();
    void setRelativeOffset([Const, Ref] PxVec3 offset);
    [Value] PxVec3 getRelativeOffset();
    void setCoefficient(float coefficient);
    float getCoefficient();
    PxArticulationLink getLink();
    PxArticulationAttachment getParent();
    boolean isLeaf();
    PxArticulationSpatialTendon getTendon();
    void release();
    attribute VoidPtr userData;
};

[Prefix="physx::"]
interface PxArticulationCache {
    void release();
    attribute PxSpatialForce externalForces;
    [Value] attribute PxRealPtr denseJacobian;
    [Value] attribute PxRealPtr massMatrix;
    [Value] attribute PxRealPtr jointVelocity;
    [Value] attribute PxRealPtr jointAcceleration;
    [Value] attribute PxRealPtr jointPosition;
    [Value] attribute PxRealPtr jointForce;
    attribute PxSpatialVelocity linkVelocity;
    attribute PxSpatialVelocity linkAcceleration;
    attribute PxArticulationRootLinkData rootLinkData;
    attribute PxSpatialForce sensorForces;
    [Value] attribute PxRealPtr coefficientMatrix;
    [Value] attribute PxRealPtr lambda;
    attribute VoidPtr scratchMemory;
    attribute VoidPtr scratchAllocator;
    attribute unsigned long version;
};

[Prefix="physx::"]
interface PxArticulationCacheFlags {
    void PxArticulationCacheFlags(unsigned long flags);
    boolean isSet(PxArticulationCacheFlagEnum flag);
    void raise(PxArticulationCacheFlagEnum flag);
    void clear(PxArticulationCacheFlagEnum flag);
};

[Prefix="physx::"]
interface PxArticulationDrive {
    void PxArticulationDrive();
    void PxArticulationDrive(float stiffness, float damping, float maxForce, PxArticulationDriveTypeEnum driveType);
    attribute float stiffness;
    attribute float damping;
    attribute float maxForce;
    attribute PxArticulationDriveTypeEnum driveType;
};

[Prefix="physx::"]
interface PxArticulationFixedTendon {
    PxArticulationTendonJoint createTendonJoint(PxArticulationTendonJoint parent, PxArticulationAxisEnum axis, float coefficient, float recipCoefficient, PxArticulationLink link);
    unsigned long getNbTendonJoints();
    void setRestLength(float restLength);
    float getRestLength();
    void setLimitParameters([Const, Ref] PxArticulationTendonLimit parameter);
    [Value] PxArticulationTendonLimit getLimitParameters();
};
PxArticulationFixedTendon implements PxArticulationTendon;

[Prefix="physx::"]
interface PxArticulationFlags {
    void PxArticulationFlags(octet flags);
    boolean isSet(PxArticulationFlagEnum flag);
    void raise(PxArticulationFlagEnum flag);
    void clear(PxArticulationFlagEnum flag);
};

[Prefix="physx::"]
interface PxArticulationJointReducedCoordinate {
    [Ref] PxArticulationLink getParentArticulationLink();
    void setParentPose([Const, Ref] PxTransform pose);
    [Value] PxTransform getParentPose();
    [Ref] PxArticulationLink getChildArticulationLink();
    void setChildPose([Const, Ref] PxTransform pose);
    [Value] PxTransform getChildPose();
    void setJointType(PxArticulationJointTypeEnum jointType);
    PxArticulationJointTypeEnum getJointType();
    void setMotion(PxArticulationAxisEnum axis, PxArticulationMotionEnum motion);
    PxArticulationMotionEnum getMotion(PxArticulationAxisEnum axis);
    void setLimitParams(PxArticulationAxisEnum axis, [Const, Ref] PxArticulationLimit limit);
    [Value] PxArticulationLimit getLimitParams(PxArticulationAxisEnum axis);
    void setDriveParams(PxArticulationAxisEnum axis, [Const, Ref] PxArticulationDrive drive);
    void setDriveTarget(PxArticulationAxisEnum axis, float target, optional boolean autowake);
    float getDriveTarget(PxArticulationAxisEnum axis);
    void setDriveVelocity(PxArticulationAxisEnum axis, float targetVel, optional boolean autowake);
    float getDriveVelocity(PxArticulationAxisEnum axis);
    void setArmature(PxArticulationAxisEnum axis, float armature);
    float getArmature(PxArticulationAxisEnum axis);
    void setFrictionCoefficient(float coefficient);
    float getFrictionCoefficient();
    void setMaxJointVelocity(float maxJointV);
    float getMaxJointVelocity();
    void setJointPosition(PxArticulationAxisEnum axis, float jointPos);
    float getJointPosition(PxArticulationAxisEnum axis);
    void setJointVelocity(PxArticulationAxisEnum axis, float jointVel);
    float getJointVelocity(PxArticulationAxisEnum axis);
};
PxArticulationJointReducedCoordinate implements PxBase;

[Prefix="physx::"]
interface PxArticulationKinematicFlags {
    void PxArticulationKinematicFlags(octet flags);
    boolean isSet(PxArticulationKinematicFlagEnum flag);
    void raise(PxArticulationKinematicFlagEnum flag);
    void clear(PxArticulationKinematicFlagEnum flag);
};

[Prefix="physx::"]
interface PxArticulationLimit {
    void PxArticulationLimit();
    void PxArticulationLimit(float low, float high);
    attribute float low;
    attribute float high;
};

[Prefix="physx::", NoDelete]
interface PxArticulationLink {
    [Ref] PxArticulationReducedCoordinate getArticulation();
    PxArticulationJointReducedCoordinate getInboundJoint();
    unsigned long getInboundJointDof();
    unsigned long getNbChildren();
    unsigned long getLinkIndex();
    void setCfmScale(float cfm);
    float getCfmScale();
};
PxArticulationLink implements PxRigidBody;

[Prefix="physx::"]
interface PxArticulationReducedCoordinate {
    PxScene getScene();
    void setSolverIterationCounts(unsigned long minPositionIters, optional unsigned long minVelocityIters);
    boolean isSleeping();
    void setSleepThreshold(float threshold);
    float getSleepThreshold();
    void setStabilizationThreshold(float threshold);
    float getStabilizationThreshold();
    void setWakeCounter(float wakeCounterValue);
    float getWakeCounter();
    void wakeUp();
    void putToSleep();
    void setMaxCOMLinearVelocity(float maxLinerVelocity);
    float getMaxCOMLinearVelocity();
    void setMaxCOMAngularVelocity(float maxAngularVelocity);
    float getMaxCOMAngularVelocity();
    PxArticulationLink createLink(PxArticulationLink parent, [Const, Ref] PxTransform pose);
    unsigned long getNbLinks();
    unsigned long getNbShapes();
    void setName([Const] DOMString name);
    [Const] DOMString getName();
    [Value] PxBounds3 getWorldBounds(optional float inflation);
    PxAggregate getAggregate();
    void setArticulationFlags([Ref] PxArticulationFlags flags);
    void setArticulationFlag(PxArticulationFlagEnum flag, boolean value);
    [Value] PxArticulationFlags getArticulationFlags();
    unsigned long getDofs();
    PxArticulationCache createCache();
    unsigned long getCacheDataSize();
    void zeroCache([Ref] PxArticulationCache cache);
    void applyCache([Ref] PxArticulationCache cache, [Ref] PxArticulationCacheFlags flags, optional boolean autowake);
    void copyInternalStateToCache([Ref] PxArticulationCache cache, [Const, Ref] PxArticulationCacheFlags flags);
    void commonInit();
    void computeGeneralizedGravityForce([Ref] PxArticulationCache cache);
    void computeCoriolisAndCentrifugalForce([Ref] PxArticulationCache cache);
    void computeGeneralizedExternalForce([Ref] PxArticulationCache cache);
    void computeJointAcceleration([Ref] PxArticulationCache cache);
    void computeJointForce([Ref] PxArticulationCache cache);
    void computeCoefficientMatrix([Ref] PxArticulationCache cache);
    void computeGeneralizedMassMatrix([Ref] PxArticulationCache cache);
    void addLoopJoint(PxConstraint joint);
    void removeLoopJoint(PxConstraint joint);
    unsigned long getNbLoopJoints();
    unsigned long getCoefficientMatrixSize();
    void setRootGlobalPose([Const, Ref] PxTransform pose, optional boolean autowake);
    [Value] PxTransform getRootGlobalPose();
    void setRootLinearVelocity([Const, Ref] PxVec3 linearVelocity, optional boolean autowake);
    [Value] PxVec3 getRootLinearVelocity();
    void setRootAngularVelocity([Const, Ref] PxVec3 angularVelocity, optional boolean autowake);
    [Value] PxVec3 getRootAngularVelocity();
    [Value] PxSpatialVelocity getLinkAcceleration(unsigned long linkId);
    unsigned long getGpuArticulationIndex();
    PxArticulationSpatialTendon createSpatialTendon();
    PxArticulationFixedTendon createFixedTendon();
    PxArticulationSensor createSensor(PxArticulationLink link, [Const, Ref] PxTransform relativePose);
    unsigned long getNbSpatialTendons();
    unsigned long getNbFixedTendons();
    unsigned long getNbSensors();
    void updateKinematic([Ref] PxArticulationKinematicFlags flags);
};
PxArticulationReducedCoordinate implements PxBase;

[Prefix="physx::"]
interface PxArticulationRootLinkData {
    void PxArticulationRootLinkData();
    [Value] attribute PxTransform transform;
    [Value] attribute PxVec3 worldLinVel;
    [Value] attribute PxVec3 worldAngVel;
    [Value] attribute PxVec3 worldLinAccel;
    [Value] attribute PxVec3 worldAngAccel;
};

[Prefix="physx::"]
interface PxArticulationSensor {
    [Value] PxSpatialForce getForces();
    [Value] PxTransform getRelativePose();
    void setRelativePose([Const, Ref] PxTransform pose);
    PxArticulationLink getLink();
    unsigned long getIndex();
    PxArticulationReducedCoordinate getArticulation();
    [Value] PxArticulationSensorFlags getFlags();
    void setFlag(PxArticulationSensorFlagEnum flag, boolean enabled);
    attribute VoidPtr userData;
};
PxArticulationSensor implements PxBase;

[Prefix="physx::"]
interface PxArticulationSensorFlags {
    void PxArticulationSensorFlags(octet flags);
    boolean isSet(PxArticulationSensorFlagEnum flag);
    void raise(PxArticulationSensorFlagEnum flag);
    void clear(PxArticulationSensorFlagEnum flag);
};

[Prefix="physx::"]
interface PxArticulationSpatialTendon {
    PxArticulationAttachment createAttachment(PxArticulationAttachment parent, float coefficient, [Const, Ref] PxVec3 relativeOffset, PxArticulationLink link);
    unsigned long getNbAttachments();
};
PxArticulationSpatialTendon implements PxArticulationTendon;

[Prefix="physx::"]
interface PxArticulationTendon {
    void setStiffness(float stiffness);
    float getStiffness();
    void setDamping(float damping);
    float getDamping();
    void setLimitStiffness(float stiffness);
    float getLimitStiffness();
    void setOffset(float offset, optional boolean autowake);
    float getOffset();
    PxArticulationReducedCoordinate getArticulation();
};
PxArticulationTendon implements PxBase;

[Prefix="physx::"]
interface PxArticulationTendonJoint {
    void setCoefficient(PxArticulationAxisEnum axis, float coefficient, float recipCoefficient);
    PxArticulationLink getLink();
    PxArticulationTendonJoint getParent();
    PxArticulationFixedTendon getTendon();
    void release();
    attribute VoidPtr userData;
};

[Prefix="physx::"]
interface PxArticulationTendonLimit {
    attribute float lowLimit;
    attribute float highLimit;
};

[Prefix="physx::"]
interface PxBVH33MidphaseDesc {
    void setToDefault();
    boolean isValid();
    attribute float meshSizePerformanceTradeOff;
    attribute PxMeshCookingHintEnum meshCookingHint;
};

[Prefix="physx::"]
interface PxBVH34MidphaseDesc {
    void setToDefault();
    boolean isValid();
    attribute unsigned long numPrimsPerLeaf;
};

[Prefix="physx::", NoDelete]
interface PxBVHStructure {
};
PxBVHStructure implements PxBase;

[Prefix="physx::", NoDelete]
interface PxBase {
    void release();
    [Const] DOMString getConcreteTypeName();
    long getConcreteType();
    void setBaseFlag(PxBaseFlagEnum flag, boolean value);
    void setBaseFlags([Ref] PxBaseFlags inFlags);
    [Value] PxBaseFlags getBaseFlags();
    boolean isReleasable();
};

[Prefix="physx::"]
interface PxBaseFlags {
    void PxBaseFlags(unsigned short flags);
    boolean isSet(PxBaseFlagEnum flag);
    void raise(PxBaseFlagEnum flag);
    void clear(PxBaseFlagEnum flag);
};

[Prefix="physx::"]
interface PxBaseMaterial {
};
PxBaseMaterial implements PxRefCounted;

[Prefix="physx::"]
interface PxBaseTask {
};

[Prefix="physx::"]
interface PxBoundedData {
    void PxBoundedData();
    attribute unsigned long count;
};
PxBoundedData implements PxStridedData;

[Prefix="physx::"]
interface PxBounds3 {
    void PxBounds3();
    void PxBounds3([Const, Ref] PxVec3 minimum, [Const, Ref] PxVec3 maximum);
    void setEmpty();
    void setMaximal();
    void include([Const, Ref] PxVec3 v);
    boolean isEmpty();
    boolean intersects([Const, Ref] PxBounds3 b);
    boolean intersects1D([Const, Ref] PxBounds3 b, unsigned long axis);
    boolean contains([Const, Ref] PxVec3 v);
    boolean isInside([Const, Ref] PxBounds3 box);
    [Value] PxVec3 getCenter();
    [Value] PxVec3 getDimensions();
    [Value] PxVec3 getExtents();
    void scaleSafe(float scale);
    void scaleFast(float scale);
    void fattenSafe(float distance);
    void fattenFast(float distance);
    boolean isFinite();
    boolean isValid();
    [Value] attribute PxVec3 minimum;
    [Value] attribute PxVec3 maximum;
};

[Prefix="physx::", NoDelete]
interface PxBoxController {
    float getHalfHeight();
    float getHalfSideExtent();
    float getHalfForwardExtent();
    boolean setHalfHeight(float halfHeight);
    boolean setHalfSideExtent(float halfSideExtent);
    boolean setHalfForwardExtent(float halfForwardExtent);
};
PxBoxController implements PxController;

[Prefix="physx::"]
interface PxBoxControllerDesc {
    void PxBoxControllerDesc();
    void setToDefault();
    attribute float halfHeight;
    attribute float halfSideExtent;
    attribute float halfForwardExtent;
};
PxBoxControllerDesc implements PxControllerDesc;

[Prefix="physx::"]
interface PxBoxGeometry {
    void PxBoxGeometry(float hx, float hy, float hz);
};
PxBoxGeometry implements PxGeometry;

[Prefix="physx::"]
interface PxBoxObstacle {
    void PxBoxObstacle();
    [Value] attribute PxVec3 mHalfExtents;
};
PxBoxObstacle implements PxObstacle;

[Prefix="physx::"]
interface PxBroadPhaseCaps {
    void PxBroadPhaseCaps();
    attribute unsigned long mMaxNbRegions;
};

[Prefix="physx::"]
interface PxBroadPhaseRegion {
    void PxBroadPhaseRegion();
    [Value] attribute PxBounds3 mBounds;
    attribute VoidPtr mUserData;
};

[Prefix="physx::"]
interface PxBroadPhaseRegionInfo {
    void PxBroadPhaseRegionInfo();
    [Value] attribute PxBroadPhaseRegion mRegion;
    attribute unsigned long mNbStaticObjects;
    attribute unsigned long mNbDynamicObjects;
    attribute boolean mActive;
    attribute boolean mOverlap;
};

[Prefix="physx::", NoDelete]
interface PxCapsuleController {
    float getRadius();
    boolean setRadius(float radius);
    float getHeight();
    boolean setHeight(float height);
    PxCapsuleClimbingModeEnum getClimbingMode();
    boolean setClimbingMode(PxCapsuleClimbingModeEnum mode);
};
PxCapsuleController implements PxController;

[Prefix="physx::"]
interface PxCapsuleControllerDesc {
    void PxCapsuleControllerDesc();
    void setToDefault();
    attribute float radius;
    attribute float height;
    attribute PxCapsuleClimbingModeEnum climbingMode;
};
PxCapsuleControllerDesc implements PxControllerDesc;

[Prefix="physx::"]
interface PxCapsuleGeometry {
    void PxCapsuleGeometry(float radius, float halfHeight);
};
PxCapsuleGeometry implements PxGeometry;

[Prefix="physx::"]
interface PxCapsuleObstacle {
    void PxCapsuleObstacle();
    attribute float mHalfHeight;
    attribute float mRadius;
};
PxCapsuleObstacle implements PxObstacle;

[Prefix="physx::", NoDelete]
interface PxCollection {
    void add([Ref] PxBase obj, optional unsigned long long id);
    void remove([Ref] PxBase obj);
    boolean contains([Ref] PxBase obj);
    void addId([Ref] PxBase obj, unsigned long long id);
    void removeId(unsigned long long id);
    unsigned long getNbObjects();
    [Ref] PxBase getObject(unsigned long index);
    PxBase find(unsigned long long id);
    unsigned long getNbIds();
    unsigned long long getId([Const, Ref] PxBase obj);
    void release();
};

[Prefix="physx::"]
interface PxCollectionExt {
    static void releaseObjects([Ref] PxCollection collection, optional boolean releaseExclusiveShapes);
    static void remove([Ref] PxCollection collection, unsigned short concreteType, optional PxCollection to);
    static PxCollection createCollection([Ref] PxScene scene);
};

[Prefix="physx::", NoDelete]
interface PxConstraint {
    PxScene getScene();
    void setActors(PxRigidActor actor0, PxRigidActor actor1);
    void markDirty();
    void setFlags([Ref] PxConstraintFlags flags);
    [Value] PxConstraintFlags getFlags();
    void setFlag(PxConstraintFlagEnum flag, boolean value);
    void getForce([Ref] PxVec3 linear, [Ref] PxVec3 angular);
    boolean isValid();
    void setBreakForce(float linear, float angular);
    void setMinResponseThreshold(float threshold);
    float getMinResponseThreshold();
};
PxConstraint implements PxBase;

[Prefix="physx::"]
interface PxConstraintConnector {
    void prepareData();
    void updateOmniPvdProperties();
    void onConstraintRelease();
    void onComShift(unsigned long actor);
    void onOriginShift([Const, Ref] PxVec3 shift);
    PxBase getSerializable();
    [Value] PxConstraintSolverPrep getPrep();
    void getConstantBlock();
    void connectToConstraint(PxConstraint constraint);
};

[Prefix="physx::"]
interface PxConstraintFlags {
    void PxConstraintFlags(unsigned short flags);
    boolean isSet(PxConstraintFlagEnum flag);
    void raise(PxConstraintFlagEnum flag);
    void clear(PxConstraintFlagEnum flag);
};

[Prefix="physx::"]
interface PxConstraintInfo {
    attribute PxConstraint constraint;
    attribute VoidPtr externalReference;
    attribute unsigned long type;
};

[Prefix="physx::"]
interface PxConstraintSolverPrep {
};

[Prefix="physx::"]
interface PxContactBuffer {
    void reset();
    boolean contact([Const, Ref] PxVec3 worldPoint, [Const, Ref] PxVec3 worldNormalIn, float separation, optional unsigned long faceIndex1);
    boolean contact([Const, Ref] PxContactPoint pt);
    [Value] attribute PxContactPoint[] contacts;
    attribute unsigned long count;
    attribute unsigned long pad;
    static readonly attribute unsigned long MAX_CONTACTS;
};

[Prefix="physx::"]
interface PxContactPair {
    unsigned long extractContacts(PxContactPairPoint userBuffer, unsigned long bufferSize);
    attribute PxShape[] shapes;
    attribute octet contactCount;
    attribute octet patchCount;
    [Value] attribute PxContactPairFlags flags;
    [Value] attribute PxPairFlags events;
};

[Prefix="physx::"]
interface PxContactPairFlags {
    void PxContactPairFlags(unsigned short flags);
    boolean isSet(PxContactPairFlagEnum flag);
    void raise(PxContactPairFlagEnum flag);
    void clear(PxContactPairFlagEnum flag);
};

[Prefix="physx::"]
interface PxContactPairHeader {
    attribute PxActor[] actors;
    [Value] attribute PxContactPairHeaderFlags flags;
    [Const] attribute PxContactPair pairs;
    attribute unsigned long nbPairs;
};

[Prefix="physx::"]
interface PxContactPairHeaderFlags {
    void PxContactPairHeaderFlags(unsigned short flags);
    boolean isSet(PxContactPairHeaderFlagEnum flag);
    void raise(PxContactPairHeaderFlagEnum flag);
    void clear(PxContactPairHeaderFlagEnum flag);
};

[Prefix="physx::"]
interface PxContactPairPoint {
    [Value] attribute PxVec3 position;
    attribute float separation;
    [Value] attribute PxVec3 normal;
    attribute unsigned long internalFaceIndex0;
    [Value] attribute PxVec3 impulse;
    attribute unsigned long internalFaceIndex1;
};

[Prefix="physx::"]
interface PxContactPoint {
    void PxContactPoint();
    [Value] attribute PxVec3 normal;
    [Value] attribute PxVec3 point;
    [Value] attribute PxVec3 targetVel;
    attribute float separation;
    attribute float maxImpulse;
    attribute float staticFriction;
    attribute octet materialFlags;
    attribute unsigned long internalFaceIndex1;
    attribute float dynamicFriction;
    attribute float restitution;
    attribute float damping;
};

[Prefix="physx::", NoDelete]
interface PxController {
    PxControllerShapeTypeEnum getType();
    void release();
    [Value] PxControllerCollisionFlags move([Const, Ref] PxVec3 disp, float minDist, float elapsedTime, [Const, Ref] PxControllerFilters filters, [Const] optional PxObstacleContext obstacles);
    boolean setPosition([Const, Ref] PxExtendedVec3 position);
    [Const, Ref] PxExtendedVec3 getPosition();
    boolean setFootPosition([Const, Ref] PxExtendedVec3 position);
    [Value] PxExtendedVec3 getFootPosition();
    PxRigidDynamic getActor();
    void setStepOffset(float offset);
    float getStepOffset();
    void setNonWalkableMode(PxControllerNonWalkableModeEnum flag);
    PxControllerNonWalkableModeEnum getNonWalkableMode();
    float getContactOffset();
    void setContactOffset(float offset);
    [Value] PxVec3 getUpDirection();
    void setUpDirection([Const, Ref] PxVec3 up);
    float getSlopeLimit();
    void setSlopeLimit(float slopeLimit);
    void invalidateCache();
    PxScene getScene();
    VoidPtr getUserData();
    void setUserData(VoidPtr userData);
    void getState([Ref] PxControllerState state);
    void getStats([Ref] PxControllerStats stats);
    void resize(float height);
};

[Prefix="physx::", NoDelete]
interface PxControllerBehaviorCallback {
};

[JSImplementation="SimpleControllerBehaviorCallback"]
interface PxControllerBehaviorCallbackImpl {
    void PxControllerBehaviorCallbackImpl();
    unsigned long getShapeBehaviorFlags([Const, Ref] PxShape shape, [Const, Ref] PxActor actor);
    unsigned long getControllerBehaviorFlags([Const, Ref] PxController controller);
    unsigned long getObstacleBehaviorFlags([Const, Ref] PxObstacle obstacle);
};

[Prefix="physx::"]
interface PxControllerBehaviorFlags {
    void PxControllerBehaviorFlags(octet flags);
    boolean isSet(PxControllerBehaviorFlagEnum flag);
    void raise(PxControllerBehaviorFlagEnum flag);
    void clear(PxControllerBehaviorFlagEnum flag);
};

[Prefix="physx::"]
interface PxControllerCollisionFlags {
    void PxControllerCollisionFlags(octet flags);
    boolean isSet(PxControllerCollisionFlagEnum flag);
    void raise(PxControllerCollisionFlagEnum flag);
    void clear(PxControllerCollisionFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxControllerDesc {
    boolean isValid();
    PxControllerShapeTypeEnum getType();
    [Value] attribute PxExtendedVec3 position;
    [Value] attribute PxVec3 upDirection;
    attribute float slopeLimit;
    attribute float invisibleWallHeight;
    attribute float maxJumpHeight;
    attribute float contactOffset;
    attribute float stepOffset;
    attribute float density;
    attribute float scaleCoeff;
    attribute float volumeGrowth;
    attribute PxUserControllerHitReport reportCallback;
    attribute PxControllerBehaviorCallback behaviorCallback;
    attribute PxControllerNonWalkableModeEnum nonWalkableMode;
    attribute PxMaterial material;
    attribute boolean registerDeletionListener;
    attribute VoidPtr userData;
};

[Prefix="physx::"]
interface PxControllerFilterCallback {
    boolean filter([Const, Ref] PxController a, [Const, Ref] PxController b);
};

[JSImplementation="PxControllerFilterCallback"]
interface PxControllerFilterCallbackImpl {
    void PxControllerFilterCallbackImpl();
    boolean filter([Const, Ref] PxController a, [Const, Ref] PxController b);
};

[Prefix="physx::"]
interface PxControllerFilters {
    void PxControllerFilters([Const] optional PxFilterData filterData);
    [Const] attribute PxFilterData mFilterData;
    attribute PxQueryFilterCallback mFilterCallback;
    [Value] attribute PxQueryFlags mFilterFlags;
    attribute PxControllerFilterCallback mCCTFilterCallback;
};

[Prefix="physx::"]
interface PxControllerHit {
    attribute PxController controller;
    [Value] attribute PxExtendedVec3 worldPos;
    [Value] attribute PxVec3 worldNormal;
    [Value] attribute PxVec3 dir;
    attribute float length;
};

[Prefix="physx::", NoDelete]
interface PxControllerManager {
    void release();
    [Ref] PxScene getScene();
    unsigned long getNbControllers();
    PxController getController(unsigned long index);
    PxController createController([Const, Ref] PxControllerDesc desc);
    void purgeControllers();
    unsigned long getNbObstacleContexts();
    PxObstacleContext getObstacleContext(unsigned long index);
    PxObstacleContext createObstacleContext();
    void computeInteractions(float elapsedTime);
    void setTessellation(boolean flag, float maxEdgeLength);
    void setOverlapRecoveryModule(boolean flag);
    void setPreciseSweeps(boolean flags);
    void setPreventVerticalSlidingAgainstCeiling(boolean flag);
    void shiftOrigin([Const, Ref] PxVec3 shift);
};

[Prefix="physx::"]
interface PxControllerObstacleHit {
    [Const] attribute VoidPtr userData;
};
PxControllerObstacleHit implements PxControllerHit;

[Prefix="physx::"]
interface PxControllerShapeHit {
    attribute PxShape shape;
    attribute PxRigidActor actor;
    attribute unsigned long triangleIndex;
};
PxControllerShapeHit implements PxControllerHit;

[Prefix="physx::"]
interface PxControllerState {
    void PxControllerState();
    [Value] attribute PxVec3 deltaXP;
    attribute PxShape touchedShape;
    attribute PxRigidActor touchedActor;
    attribute unsigned long touchedObstacleHandle;
    attribute unsigned long collisionFlags;
    attribute boolean standOnAnotherCCT;
    attribute boolean standOnObstacle;
    attribute boolean isMovingUp;
};

[Prefix="physx::"]
interface PxControllerStats {
    attribute unsigned short nbIterations;
    attribute unsigned short nbFullUpdates;
    attribute unsigned short nbPartialUpdates;
    attribute unsigned short nbTessellation;
};

[Prefix="physx::"]
interface PxControllersHit {
    attribute PxController other;
};
PxControllersHit implements PxControllerHit;

[Prefix="physx::"]
interface PxConvexFlags {
    void PxConvexFlags(unsigned short flags);
    boolean isSet(PxConvexFlagEnum flag);
    void raise(PxConvexFlagEnum flag);
    void clear(PxConvexFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxConvexMesh {
    unsigned long getNbVertices();
    [Const] PxVec3 getVertices();
    [Value] PxU8ConstPtr getIndexBuffer();
    unsigned long getNbPolygons();
    boolean getPolygonData(unsigned long index, [Ref] PxHullPolygon data);
    [Value] PxBounds3 getLocalBounds();
    boolean isGpuCompatible();
};
PxConvexMesh implements PxRefCounted;

[Prefix="physx::"]
interface PxConvexMeshDesc {
    void PxConvexMeshDesc();
    [Value] attribute PxBoundedData points;
    [Value] attribute PxConvexFlags flags;
};

[Prefix="physx::"]
interface PxConvexMeshGeometry {
    void PxConvexMeshGeometry(PxConvexMesh mesh, [Const, Ref] optional PxMeshScale scaling, [Ref] optional PxConvexMeshGeometryFlags flags);
};
PxConvexMeshGeometry implements PxGeometry;

[Prefix="physx::"]
interface PxConvexMeshGeometryFlags {
    void PxConvexMeshGeometryFlags(octet flags);
    boolean isSet(PxConvexMeshGeometryFlagEnum flag);
    void raise(PxConvexMeshGeometryFlagEnum flag);
    void clear(PxConvexMeshGeometryFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxCooking {
    void release();
    PxConvexMesh createConvexMesh([Const, Ref] PxConvexMeshDesc desc, [Ref] PxInsertionCallback insertionCallback);
    PxTriangleMesh createTriangleMesh([Const, Ref] PxTriangleMeshDesc desc, [Ref] PxInsertionCallback insertionCallback);
    PxHeightField createHeightField([Const, Ref] PxHeightFieldDesc desc, [Ref] PxInsertionCallback insertionCallback);
};

[Prefix="physx::"]
interface PxCookingParams {
    void PxCookingParams([Const, Ref] PxTolerancesScale sc);
    attribute float areaTestEpsilon;
    attribute float planeTolerance;
    attribute PxConvexMeshCookingTypeEnum convexMeshCookingType;
    attribute boolean suppressTriangleMeshRemapTable;
    attribute boolean buildTriangleAdjacencies;
    attribute boolean buildGPUData;
    [Value] attribute PxTolerancesScale scale;
    [Value] attribute PxMeshPreprocessingFlags meshPreprocessParams;
    attribute float meshWeldTolerance;
    [Value] attribute PxMidphaseDesc midphaseDesc;
    attribute unsigned long gaussMapLimit;
};

[Prefix="physx::"]
interface PxCpuDispatcher {
};

[Prefix="physx::"]
interface PxD6Joint {
    void setMotion(PxD6AxisEnum axis, PxD6MotionEnum type);
    PxD6MotionEnum getMotion(PxD6AxisEnum axis);
    float getTwistAngle();
    float getSwingYAngle();
    float getSwingZAngle();
    void setDistanceLimit([Const, Ref] PxJointLinearLimit limit);
    void setLinearLimit(PxD6AxisEnum axis, [Const, Ref] PxJointLinearLimitPair limit);
    void setTwistLimit([Const, Ref] PxJointAngularLimitPair limit);
    void setSwingLimit([Const, Ref] PxJointLimitCone limit);
    void setPyramidSwingLimit([Const, Ref] PxJointLimitPyramid limit);
    void setDrive(PxD6DriveEnum index, [Const, Ref] PxD6JointDrive drive);
    [Value] PxD6JointDrive getDrive(PxD6DriveEnum index);
    void setDrivePosition([Const, Ref] PxTransform pose, optional boolean autowake);
    [Value] PxTransform getDrivePosition();
    void setDriveVelocity([Const, Ref] PxVec3 linear, [Const, Ref] PxVec3 angular);
    void getDriveVelocity([Ref] PxVec3 linear, [Ref] PxVec3 angular);
    void setProjectionLinearTolerance(float tolerance);
    float getProjectionLinearTolerance();
    void setProjectionAngularTolerance(float tolerance);
    float getProjectionAngularTolerance();
};
PxD6Joint implements PxJoint;

[Prefix="physx::"]
interface PxD6JointDrive {
    void PxD6JointDrive();
    void PxD6JointDrive(float driveStiffness, float driveDamping, float driveForceLimit, optional boolean isAcceleration);
    attribute float forceLimit;
    [Value] attribute PxD6JointDriveFlags flags;
};
PxD6JointDrive implements PxSpring;

[Prefix="physx::"]
interface PxD6JointDriveFlags {
    void PxD6JointDriveFlags(unsigned long flags);
    boolean isSet(PxD6JointDriveFlagEnum flag);
    void raise(PxD6JointDriveFlagEnum flag);
    void clear(PxD6JointDriveFlagEnum flag);
};

[Prefix="physx::"]
interface PxDefaultAllocator {
    void PxDefaultAllocator();
};

[Prefix="physx::"]
interface PxDefaultCpuDispatcher {
};
PxDefaultCpuDispatcher implements PxCpuDispatcher;

[Prefix="physx::"]
interface PxDefaultErrorCallback {
    void PxDefaultErrorCallback();
};
PxDefaultErrorCallback implements PxErrorCallback;

[Prefix="physx::"]
interface PxDefaultMemoryInputData {
    void PxDefaultMemoryInputData([Ref] PxU8Ptr data, unsigned long length);
    unsigned long read(VoidPtr dest, unsigned long count);
    unsigned long getLength();
    void seek(unsigned long pos);
    unsigned long tell();
};
PxDefaultMemoryInputData implements PxInputData;

[Prefix="physx::"]
interface PxDefaultMemoryOutputStream {
    void PxDefaultMemoryOutputStream();
    void write(VoidPtr src, unsigned long count);
    unsigned long getSize();
    VoidPtr getData();
};
PxDefaultMemoryOutputStream implements PxOutputStream;

[Prefix="physx::"]
interface PxDistanceJoint {
    float getDistance();
    void setMinDistance(float distance);
    float getMinDistance();
    void setMaxDistance(float distance);
    float getMaxDistance();
    void setTolerance(float tolerance);
    float getTolerance();
    void setStiffness(float stiffness);
    float getStiffness();
    void setDamping(float damping);
    float getDamping();
    void setDistanceJointFlags([Ref] PxDistanceJointFlags flags);
    void setDistanceJointFlag(PxDistanceJointFlagEnum flag, boolean value);
    [Value] PxDistanceJointFlags getDistanceJointFlags();
};
PxDistanceJoint implements PxJoint;

[Prefix="physx::"]
interface PxDistanceJointFlags {
    void PxDistanceJointFlags(unsigned short flags);
    boolean isSet(PxDistanceJointFlagEnum flag);
    void raise(PxDistanceJointFlagEnum flag);
    void clear(PxDistanceJointFlagEnum flag);
};

[Prefix="physx::"]
interface PxDominanceGroupPair {
    void PxDominanceGroupPair(octet a, octet b);
    attribute octet dominance0;
    attribute octet dominance1;
};

[Prefix="physx::"]
interface PxErrorCallback {
    void reportError(PxErrorCodeEnum code, [Const] DOMString message, [Const] DOMString file, long line);
};

[JSImplementation="PxErrorCallback"]
interface PxErrorCallbackImpl {
    void PxErrorCallbackImpl();
    void reportError(PxErrorCodeEnum code, [Const] DOMString message, [Const] DOMString file, long line);
};

[Prefix="physx::"]
interface PxExtendedVec3 {
    void PxExtendedVec3();
    void PxExtendedVec3(double x, double y, double z);
    attribute double x;
    attribute double y;
    attribute double z;
};

[Prefix="physx::"]
interface PxFilterData {
    void PxFilterData();
    void PxFilterData(unsigned long w0, unsigned long w1, unsigned long w2, unsigned long w3);
    attribute unsigned long word0;
    attribute unsigned long word1;
    attribute unsigned long word2;
    attribute unsigned long word3;
};

[Prefix="physx::"]
interface PxFixedJoint {
    void setProjectionLinearTolerance(float tolerance);
    float getProjectionLinearTolerance();
    void setProjectionAngularTolerance(float tolerance);
    float getProjectionAngularTolerance();
};
PxFixedJoint implements PxJoint;

[Prefix="physx::", NoDelete]
interface PxFoundation {
    void release();
};

[Prefix="physx::"]
interface PxGeomRaycastHit {
    boolean hadInitialOverlap();
    attribute float u;
    attribute float v;
};
PxGeomRaycastHit implements PxLocationHit;

[Prefix="physx::"]
interface PxGeomSweepHit {
    boolean hadInitialOverlap();
};
PxGeomSweepHit implements PxLocationHit;

[Prefix="physx::"]
interface PxGeometry {
    PxGeometryTypeEnum getType();
};

[Prefix="physx::"]
interface PxGeometryHolder {
    void PxGeometryHolder();
    void PxGeometryHolder([Const, Ref] PxGeometry geometry);
    PxGeometryTypeEnum getType();
    [Ref] PxSphereGeometry sphere();
    [Ref] PxPlaneGeometry plane();
    [Ref] PxCapsuleGeometry capsule();
    [Ref] PxBoxGeometry box();
    [Ref] PxConvexMeshGeometry convexMesh();
    [Ref] PxTriangleMeshGeometry triangleMesh();
    [Ref] PxHeightFieldGeometry heightField();
    void storeAny([Const, Ref] PxGeometry geometry);
};

[Prefix="physx::"]
interface PxGeometryQuery {
    static boolean sweep([Const, Ref] PxVec3 unitDir, float maxDist, [Const, Ref] PxGeometry geom0, [Const, Ref] PxTransform pose0, [Const, Ref] PxGeometry geom1, [Const, Ref] PxTransform pose1, [Ref] PxSweepHit sweepHit, [Ref] optional PxHitFlags hitFlags, optional float inflation);
    static boolean overlap([Const, Ref] PxGeometry geom0, [Const, Ref] PxTransform pose0, [Const, Ref] PxGeometry geom1, [Const, Ref] PxTransform pose1);
    static unsigned long raycast([Const, Ref] PxVec3 origin, [Const, Ref] PxVec3 unitDir, [Const, Ref] PxGeometry geom, [Const, Ref] PxTransform pose, float maxDist, [Ref] PxHitFlags hitFlags, unsigned long maxHits, PxRaycastHit rayHits);
    static float pointDistance([Const, Ref] PxVec3 point, [Const, Ref] PxGeometry geom, [Const, Ref] PxTransform pose, optional PxVec3 closestPoint);
    [Value] static PxBounds3 getWorldBounds([Const, Ref] PxGeometry geom, [Const, Ref] PxTransform pose, optional float inflation);
    static boolean isValid([Const, Ref] PxGeometry geom);
};

[Prefix="physx::", NoDelete]
interface PxHeightField {
    unsigned long saveCells(VoidPtr destBuffer, unsigned long destBufferSize);
    boolean modifySamples(long startCol, long startRow, [Const, Ref] PxHeightFieldDesc subfieldDesc, optional boolean shrinkBounds);
    unsigned long getNbRows();
    unsigned long getNbColumns();
    PxHeightFieldFormatEnum getFormat();
    unsigned long getSampleStride();
    float getConvexEdgeThreshold();
    [Value] PxHeightFieldFlags getFlags();
    float getHeight(float x, float z);
    unsigned short getTriangleMaterialIndex(unsigned long triangleIndex);
    [Value] PxVec3 getTriangleNormal(unsigned long triangleIndex);
    [Const, Ref] PxHeightFieldSample getSample(unsigned long row, unsigned long column);
    unsigned long getTimestamp();
};
PxHeightField implements PxRefCounted;

[Prefix="physx::"]
interface PxHeightFieldDesc {
    void PxHeightFieldDesc();
    void setToDefault();
    boolean isValid();
    attribute unsigned long nbRows;
    attribute unsigned long nbColumns;
    attribute PxHeightFieldFormatEnum format;
    [Value] attribute PxStridedData samples;
    attribute float convexEdgeThreshold;
    [Value] attribute PxHeightFieldFlags flags;
};

[Prefix="physx::"]
interface PxHeightFieldFlags {
    void PxHeightFieldFlags(unsigned short flags);
    boolean isSet(PxHeightFieldFlagEnum flag);
    void raise(PxHeightFieldFlagEnum flag);
    void clear(PxHeightFieldFlagEnum flag);
};

[Prefix="physx::"]
interface PxHeightFieldGeometry {
    void PxHeightFieldGeometry();
    void PxHeightFieldGeometry(PxHeightField hf, [Ref] PxMeshGeometryFlags flags, float heightScale, float rowScale, float columnScale);
    boolean isValid();
    attribute PxHeightField heightField;
    attribute float heightScale;
    attribute float rowScale;
    attribute float columnScale;
    [Value] attribute PxMeshGeometryFlags heightFieldFlags;
};
PxHeightFieldGeometry implements PxGeometry;

[Prefix="physx::"]
interface PxHeightFieldSample {
    void PxHeightFieldSample();
    octet tessFlag();
    void clearTessFlag();
    void setTessFlag();
    attribute short height;
    attribute octet materialIndex0;
    attribute octet materialIndex1;
};

[Prefix="physx::"]
interface PxHitFlags {
    void PxHitFlags(unsigned short flags);
    boolean isSet(PxHitFlagEnum flag);
    void raise(PxHitFlagEnum flag);
    void clear(PxHitFlagEnum flag);
};

[Prefix="physx::"]
interface PxHullPolygon {
    void PxHullPolygon();
    attribute float[] mPlane;
    attribute short mNbVerts;
    attribute short mIndexBase;
};

[Prefix="physx::"]
interface PxInputData {
};

[Prefix="physx::", NoDelete]
interface PxInsertionCallback {
};

[Prefix="physx::", NoDelete]
interface PxJoint {
    void setActors(PxRigidActor actor0, PxRigidActor actor1);
    void setLocalPose(PxJointActorIndexEnum actor, [Const, Ref] PxTransform localPose);
    [Value] PxTransform getLocalPose(PxJointActorIndexEnum actor);
    [Value] PxTransform getRelativeTransform();
    [Value] PxVec3 getRelativeLinearVelocity();
    [Value] PxVec3 getRelativeAngularVelocity();
    void setBreakForce(float force, float torque);
    void setConstraintFlags([Ref] PxConstraintFlags flags);
    void setConstraintFlag(PxConstraintFlagEnum flag, boolean value);
    [Value] PxConstraintFlags getConstraintFlags();
    void setInvMassScale0(float invMassScale);
    float getInvMassScale0();
    void setInvMassScale1(float invMassScale);
    float getInvMassScale1();
    PxConstraint getConstraint();
    void setName([Const] DOMString name);
    [Const] DOMString getName();
    PxScene getScene();
    attribute VoidPtr userData;
};
PxJoint implements PxBase;

[Prefix="physx::"]
interface PxJointAngularLimitPair {
    void PxJointAngularLimitPair(float lowerLimit, float upperLimit, [Const, Ref] PxSpring spring);
    attribute float upper;
    attribute float lower;
};
PxJointAngularLimitPair implements PxJointLimitParameters;

[Prefix="physx::"]
interface PxJointLimitCone {
    void PxJointLimitCone(float yLimitAngle, float zLimitAngle, [Const, Ref] PxSpring spring);
    attribute float yAngle;
    attribute float zAngle;
};
PxJointLimitCone implements PxJointLimitParameters;

[Prefix="physx::", NoDelete]
interface PxJointLimitParameters {
    boolean isValid();
    boolean isSoft();
    attribute float restitution;
    attribute float bounceThreshold;
    attribute float stiffness;
    attribute float damping;
};

[Prefix="physx::"]
interface PxJointLimitPyramid {
    void PxJointLimitPyramid(float yLimitAngleMin, float yLimitAngleMax, float zLimitAngleMin, float zLimitAngleMax, [Const, Ref] PxSpring spring);
    attribute float yAngleMin;
    attribute float yAngleMax;
    attribute float zAngleMin;
    attribute float zAngleMax;
};
PxJointLimitPyramid implements PxJointLimitParameters;

[Prefix="physx::"]
interface PxJointLinearLimit {
    void PxJointLinearLimit(float extent, [Const, Ref] PxSpring spring);
    attribute float value;
};
PxJointLinearLimit implements PxJointLimitParameters;

[Prefix="physx::"]
interface PxJointLinearLimitPair {
    void PxJointLinearLimitPair(float lowerLimit, float upperLimit, [Const, Ref] PxSpring spring);
    attribute float upper;
    attribute float lower;
};
PxJointLinearLimitPair implements PxJointLimitParameters;

[Prefix="physx::"]
interface PxLocationHit {
    [Value] attribute PxHitFlags flags;
    [Value] attribute PxVec3 position;
    [Value] attribute PxVec3 normal;
    attribute float distance;
};
PxLocationHit implements PxQueryHit;

[Prefix="physx::"]
interface PxMassProperties {
    void PxMassProperties();
    void PxMassProperties(float m, [Const, Ref] PxMat33 inertiaT, [Const, Ref] PxVec3 com);
    void PxMassProperties([Const, Ref] PxGeometry geometry);
    void translate([Const, Ref] PxVec3 t);
    [Value] static PxVec3 getMassSpaceInertia([Const, Ref] PxMat33 inertia, [Ref] PxQuat massFrame);
    [Value] static PxMat33 translateInertia([Const, Ref] PxMat33 inertia, float mass, [Const, Ref] PxVec3 t);
    [Value] static PxMat33 rotateInertia([Const, Ref] PxMat33 inertia, [Const, Ref] PxQuat q);
    [Value] static PxMat33 scaleInertia([Const, Ref] PxMat33 inertia, [Const, Ref] PxQuat scaleRotation, [Const, Ref] PxVec3 scale);
    [Value] static PxMassProperties sum([Const] PxMassProperties props, [Const] PxTransform transforms, unsigned long count);
    [Value] attribute PxMat33 inertiaTensor;
    [Value] attribute PxVec3 centerOfMass;
    attribute float mass;
};

[Prefix="physx::"]
interface PxMat33 {
    void PxMat33();
    void PxMat33(PxIDENTITYEnum r);
    [Value] attribute PxVec3 column0;
    [Value] attribute PxVec3 column1;
    [Value] attribute PxVec3 column2;
};

[Prefix="physx::", NoDelete]
interface PxMaterial {
    void setDynamicFriction(float coef);
    float getDynamicFriction();
    void setStaticFriction(float coef);
    float getStaticFriction();
    void setRestitution(float coef);
    float getRestitution();
    void setFlag(PxMaterialFlagEnum flag, boolean b);
    void setFlags([Ref] PxMaterialFlags flags);
    [Value] PxMaterialFlags getFlags();
    void setFrictionCombineMode(PxCombineModeEnum combMode);
    PxCombineModeEnum getFrictionCombineMode();
    void setRestitutionCombineMode(PxCombineModeEnum combMode);
    PxCombineModeEnum getRestitutionCombineMode();
    attribute VoidPtr userData;
};
PxMaterial implements PxBaseMaterial;

interface PxMaterialConstPtr {
};

[Prefix="physx::"]
interface PxMaterialFlags {
    void PxMaterialFlags(unsigned short flags);
    boolean isSet(PxMaterialFlagEnum flag);
    void raise(PxMaterialFlagEnum flag);
    void clear(PxMaterialFlagEnum flag);
};

interface PxMaterialPtr {
};

[Prefix="physx::"]
interface PxMeshFlags {
    void PxMeshFlags(octet flags);
    boolean isSet(PxMeshFlagEnum flag);
    void raise(PxMeshFlagEnum flag);
    void clear(PxMeshFlagEnum flag);
};

[Prefix="physx::"]
interface PxMeshGeometryFlags {
    void PxMeshGeometryFlags(octet flags);
    boolean isSet(PxMeshGeometryFlagEnum flag);
    void raise(PxMeshGeometryFlagEnum flag);
    void clear(PxMeshGeometryFlagEnum flag);
};

[Prefix="physx::"]
interface PxMeshOverlapUtil {
    void PxMeshOverlapUtil();
    unsigned long findOverlap([Const, Ref] PxGeometry geom, [Const, Ref] PxTransform geomPose, [Const, Ref] PxTriangleMeshGeometry meshGeom, [Const, Ref] PxTransform meshPose);
    [Value] PxU32ConstPtr getResults();
    unsigned long getNbResults();
};

[Prefix="physx::"]
interface PxMeshPreprocessingFlags {
    void PxMeshPreprocessingFlags(unsigned long flags);
    boolean isSet(PxMeshPreprocessingFlagEnum flag);
    void raise(PxMeshPreprocessingFlagEnum flag);
    void clear(PxMeshPreprocessingFlagEnum flag);
};

[Prefix="physx::"]
interface PxMeshScale {
    void PxMeshScale();
    void PxMeshScale(float r);
    void PxMeshScale([Const, Ref] PxVec3 s, [Const, Ref] PxQuat r);
};

[Prefix="physx::"]
interface PxMidphaseDesc {
    void PxMidphaseDesc();
    PxMeshMidPhaseEnum getType();
    void setToDefault(PxMeshMidPhaseEnum type);
    boolean isValid();
    [Value] attribute PxBVH33MidphaseDesc mBVH33Desc;
    [Value] attribute PxBVH34MidphaseDesc mBVH34Desc;
};

[Prefix="physx::"]
interface PxObstacle {
    PxGeometryTypeEnum getType();
    attribute VoidPtr mUserData;
    [Value] attribute PxExtendedVec3 mPos;
    [Value] attribute PxQuat mRot;
};

[Prefix="physx::"]
interface PxObstacleContext {
    void release();
    [Ref] PxControllerManager getControllerManager();
    unsigned long addObstacle([Const, Ref] PxObstacle obstacle);
    boolean removeObstacle(unsigned long handle);
    boolean updateObstacle(unsigned long handle, [Const, Ref] PxObstacle obstacle);
    unsigned long getNbObstacles();
    [Const] PxObstacle getObstacle(unsigned long i);
    [Const] PxObstacle getObstacleByHandle(unsigned long handle);
};

[Prefix="physx::"]
interface PxOutputStream {
};

interface PxOverlapBuffer10 {
    void PxOverlapBuffer10();
    unsigned long getNbAnyHits();
    [Const, Ref] PxOverlapHit getAnyHit(unsigned long index);
    unsigned long getNbTouches();
    [Const] PxOverlapHit getTouches();
    [Const, Ref] PxOverlapHit getTouch(unsigned long index);
    unsigned long getMaxNbTouches();
    [Value] attribute PxOverlapHit block;
    attribute boolean hasBlock;
};
PxOverlapBuffer10 implements PxOverlapCallback;

[Prefix="physx::"]
interface PxOverlapCallback {
    boolean hasAnyHits();
};

[Prefix="physx::"]
interface PxOverlapHit {
    attribute PxRigidActor actor;
    attribute PxShape shape;
};
PxOverlapHit implements PxQueryHit;

[Prefix="physx::"]
interface PxPairFlags {
    void PxPairFlags(unsigned short flags);
    boolean isSet(PxPairFlagEnum flag);
    void raise(PxPairFlagEnum flag);
    void clear(PxPairFlagEnum flag);
};

[Prefix="physx::"]
interface PxPhysics {
    void release();
    [Ref] PxFoundation getFoundation();
    PxAggregate createAggregate(unsigned long size, unsigned long maxShape, boolean enableSelfCollision);
    [Const, Ref] PxTolerancesScale getTolerancesScale();
    PxScene createScene([Const, Ref] PxSceneDesc sceneDesc);
    PxRigidStatic createRigidStatic([Const, Ref] PxTransform pose);
    PxRigidDynamic createRigidDynamic([Const, Ref] PxTransform pose);
    PxShape createShape([Const, Ref] PxGeometry geometry, [Const, Ref] PxMaterial material, optional boolean isExclusive, [Ref] optional PxShapeFlags shapeFlags);
    long getNbShapes();
    PxArticulationReducedCoordinate createArticulationReducedCoordinate();
    PxMaterial createMaterial(float staticFriction, float dynamicFriction, float restitution);
    [Ref] PxInsertionCallback getPhysicsInsertionCallback();
};

[Prefix="physx::"]
interface PxPlane {
    void PxPlane();
    void PxPlane(float nx, float ny, float nz, float distance);
    void PxPlane([Const, Ref] PxVec3 normal, float distance);
    void PxPlane([Const, Ref] PxVec3 p0, [Const, Ref] PxVec3 p1, [Const, Ref] PxVec3 p2);
    float distance([Const, Ref] PxVec3 p);
    boolean contains([Const, Ref] PxVec3 p);
    [Value] PxVec3 project([Const, Ref] PxVec3 p);
    [Value] PxVec3 pointInPlane();
    void normalize();
    [Value] PxPlane transform([Const, Ref] PxTransform pose);
    [Value] PxPlane inverseTransform([Const, Ref] PxTransform pose);
    [Value] attribute PxVec3 n;
    attribute float d;
};

[Prefix="physx::"]
interface PxPlaneGeometry {
    void PxPlaneGeometry();
};
PxPlaneGeometry implements PxGeometry;

[Prefix="physx::"]
interface PxPrismaticJoint {
    float getPosition();
    float getVelocity();
    void setLimit([Const, Ref] PxJointLinearLimitPair limit);
    void setPrismaticJointFlags([Ref] PxPrismaticJointFlags flags);
    void setPrismaticJointFlag(PxPrismaticJointFlagEnum flag, boolean value);
    [Value] PxPrismaticJointFlags getPrismaticJointFlags();
    void setProjectionLinearTolerance(float tolerance);
    float getProjectionLinearTolerance();
    void setProjectionAngularTolerance(float tolerance);
    float getProjectionAngularTolerance();
};
PxPrismaticJoint implements PxJoint;

[Prefix="physx::"]
interface PxPrismaticJointFlags {
    void PxPrismaticJointFlags(unsigned short flags);
    boolean isSet(PxPrismaticJointFlagEnum flag);
    void raise(PxPrismaticJointFlagEnum flag);
    void clear(PxPrismaticJointFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxPvd {
};

[Prefix="physx::"]
interface PxQuat {
    void PxQuat();
    void PxQuat(PxIDENTITYEnum r);
    void PxQuat(float x, float y, float z, float w);
    boolean isIdentity();
    boolean isFinite();
    boolean isUnit();
    boolean isSane();
    float getAngle();
    float getAngle([Const, Ref] PxQuat q);
    float magnitudeSquared();
    float dot([Const, Ref] PxQuat q);
    [Value] PxQuat getNormalized();
    float magnitude();
    float normalize();
    [Value] PxQuat getConjugate();
    [Value] PxVec3 getImaginaryPart();
    [Value] PxVec3 getBasisVector0();
    [Value] PxVec3 getBasisVector1();
    [Value] PxVec3 getBasisVector2();
    [Value] PxVec3 rotate([Const, Ref] PxVec3 v);
    [Value] PxVec3 rotateInv([Const, Ref] PxVec3 v);
    attribute float x;
    attribute float y;
    attribute float z;
    attribute float w;
};

[Prefix="physx::"]
interface PxQueryFilterCallback {
};

[JSImplementation="SimpleQueryFilterCallback"]
interface PxQueryFilterCallbackImpl {
    void PxQueryFilterCallbackImpl();
    unsigned long simplePreFilter([Const, Ref] PxFilterData filterData, [Const] PxShape shape, [Const] PxRigidActor actor, [Ref] PxHitFlags queryFlags);
    unsigned long simplePostFilter([Const, Ref] PxFilterData filterData, [Const, Ref] PxQueryHit hit);
};

[Prefix="physx::"]
interface PxQueryFilterData {
    void PxQueryFilterData();
    void PxQueryFilterData([Const, Ref] PxFilterData fd, [Ref] PxQueryFlags f);
    void PxQueryFilterData([Ref] PxQueryFlags f);
    [Value] attribute PxFilterData data;
    [Value] attribute PxQueryFlags flags;
};

[Prefix="physx::"]
interface PxQueryFlags {
    void PxQueryFlags(unsigned short flags);
    boolean isSet(PxQueryFlagEnum flag);
    void raise(PxQueryFlagEnum flag);
    void clear(PxQueryFlagEnum flag);
};

[Prefix="physx::"]
interface PxQueryHit {
    attribute unsigned long faceIndex;
};

interface PxRaycastBuffer10 {
    void PxRaycastBuffer10();
    unsigned long getNbAnyHits();
    [Const, Ref] PxRaycastHit getAnyHit(unsigned long index);
    unsigned long getNbTouches();
    [Const] PxRaycastHit getTouches();
    [Const, Ref] PxRaycastHit getTouch(unsigned long index);
    unsigned long getMaxNbTouches();
    [Value] attribute PxRaycastHit block;
    attribute boolean hasBlock;
};
PxRaycastBuffer10 implements PxRaycastCallback;

[Prefix="physx::"]
interface PxRaycastCallback {
    boolean hasAnyHits();
};

[Prefix="physx::"]
interface PxRaycastHit {
    void PxRaycastHit();
    attribute PxRigidActor actor;
    attribute PxShape shape;
};
PxRaycastHit implements PxGeomRaycastHit;

interface PxRealPtr {
};

[Prefix="physx::", NoDelete]
interface PxRefCounted {
    unsigned long getReferenceCount();
    void acquireReference();
};
PxRefCounted implements PxBase;

[Prefix="physx::"]
interface PxRevoluteJoint {
    float getAngle();
    float getVelocity();
    void setLimit([Const, Ref] PxJointAngularLimitPair limits);
    void setDriveVelocity(float velocity, optional boolean autowake);
    float getDriveVelocity();
    void setDriveForceLimit(float limit);
    float getDriveForceLimit();
    void setDriveGearRatio(float ratio);
    float getDriveGearRatio();
    void setRevoluteJointFlags([Ref] PxRevoluteJointFlags flags);
    void setRevoluteJointFlag(PxRevoluteJointFlagEnum flag, boolean value);
    [Value] PxRevoluteJointFlags getRevoluteJointFlags();
    void setProjectionLinearTolerance(float tolerance);
    float getProjectionLinearTolerance();
    void setProjectionAngularTolerance(float tolerance);
    float getProjectionAngularTolerance();
};
PxRevoluteJoint implements PxJoint;

[Prefix="physx::"]
interface PxRevoluteJointFlags {
    void PxRevoluteJointFlags(unsigned short flags);
    boolean isSet(PxRevoluteJointFlagEnum flag);
    void raise(PxRevoluteJointFlagEnum flag);
    void clear(PxRevoluteJointFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxRigidActor {
    [Value] PxTransform getGlobalPose();
    void setGlobalPose([Const, Ref] PxTransform pose, optional boolean autowake);
    boolean attachShape([Ref] PxShape shape);
    void detachShape([Ref] PxShape shape, optional boolean wakeOnLostTouch);
    unsigned long getNbShapes();
    unsigned long getNbConstraints();
};
PxRigidActor implements PxActor;

[Prefix="physx::"]
interface PxRigidActorExt {
    static PxShape createExclusiveShape([Ref] PxRigidActor actor, [Const, Ref] PxGeometry geometry, [Const, Ref] PxMaterial material, [Ref] optional PxShapeFlags flags);
};

[Prefix="physx::", NoDelete]
interface PxRigidBody {
    void setCMassLocalPose([Const, Ref] PxTransform pose);
    [Value] PxTransform getCMassLocalPose();
    void setMass(float mass);
    float getMass();
    float getInvMass();
    void setMassSpaceInertiaTensor([Const, Ref] PxVec3 m);
    [Value] PxVec3 getMassSpaceInertiaTensor();
    [Value] PxVec3 getMassSpaceInvInertiaTensor();
    void setLinearDamping(float linDamp);
    float getLinearDamping();
    void setAngularDamping(float angDamp);
    float getAngularDamping();
    [Value] PxVec3 getLinearVelocity();
    [Value] PxVec3 getAngularVelocity();
    void setMaxLinearVelocity(float maxLinVel);
    float getMaxLinearVelocity();
    void setMaxAngularVelocity(float maxAngVel);
    float getMaxAngularVelocity();
    void addForce([Const, Ref] PxVec3 force, optional PxForceModeEnum mode, optional boolean autowake);
    void addTorque([Const, Ref] PxVec3 torque, optional PxForceModeEnum mode, optional boolean autowake);
    void clearForce(PxForceModeEnum mode);
    void clearTorque(PxForceModeEnum mode);
    void setForceAndTorque([Const, Ref] PxVec3 force, [Const, Ref] PxVec3 torque, optional PxForceModeEnum mode);
    void setRigidBodyFlag(PxRigidBodyFlagEnum flag, boolean value);
    void setRigidBodyFlags([Ref] PxRigidBodyFlags inFlags);
    [Value] PxRigidBodyFlags getRigidBodyFlags();
    void setMinCCDAdvanceCoefficient(float advanceCoefficient);
    float getMinCCDAdvanceCoefficient();
    void setMaxDepenetrationVelocity(float biasClamp);
    float getMaxDepenetrationVelocity();
    void setMaxContactImpulse(float maxImpulse);
    float getMaxContactImpulse();
    void setContactSlopCoefficient(float slopCoefficient);
    float getContactSlopCoefficient();
};
PxRigidBody implements PxRigidActor;

[Prefix="physx::"]
interface PxRigidBodyExt {
    static boolean updateMassAndInertia([Ref] PxRigidBody body, float density, optional PxVec3 massLocalPose, optional boolean includeNonSimShapes);
    static boolean setMassAndUpdateInertia([Ref] PxRigidBody body, float mass, optional PxVec3 massLocalPose, optional boolean includeNonSimShapes);
    static void addForceAtPos([Ref] PxRigidBody body, [Const, Ref] PxVec3 force, [Const, Ref] PxVec3 pos, optional PxForceModeEnum mode, optional boolean wakeup);
    static void addForceAtLocalPos([Ref] PxRigidBody body, [Const, Ref] PxVec3 force, [Const, Ref] PxVec3 pos, optional PxForceModeEnum mode, optional boolean wakeup);
    static void addLocalForceAtPos([Ref] PxRigidBody body, [Const, Ref] PxVec3 force, [Const, Ref] PxVec3 pos, optional PxForceModeEnum mode, optional boolean wakeup);
    static void addLocalForceAtLocalPos([Ref] PxRigidBody body, [Const, Ref] PxVec3 force, [Const, Ref] PxVec3 pos, optional PxForceModeEnum mode, optional boolean wakeup);
    [Value] static PxVec3 getVelocityAtPos([Const, Ref] PxRigidBody body, [Const, Ref] PxVec3 pos);
    [Value] static PxVec3 getLocalVelocityAtLocalPos([Const, Ref] PxRigidBody body, [Const, Ref] PxVec3 pos);
    [Value] static PxVec3 getVelocityAtOffset([Const, Ref] PxRigidBody body, [Const, Ref] PxVec3 pos);
    static void computeVelocityDeltaFromImpulse([Const, Ref] PxRigidBody body, [Const, Ref] PxVec3 impulsiveForce, [Const, Ref] PxVec3 impulsiveTorque, [Ref] PxVec3 deltaLinearVelocity, [Ref] PxVec3 deltaAngularVelocity);
    static void computeVelocityDeltaFromImpulse([Const, Ref] PxRigidBody body, [Const, Ref] PxTransform globalPose, [Const, Ref] PxVec3 point, [Const, Ref] PxVec3 impulse, float invMassScale, float invInertiaScale, [Ref] PxVec3 deltaLinearVelocity, [Ref] PxVec3 deltaAngularVelocity);
    static void computeLinearAngularImpulse([Const, Ref] PxRigidBody body, [Const, Ref] PxTransform globalPose, [Const, Ref] PxVec3 point, [Const, Ref] PxVec3 impulse, float invMassScale, float invInertiaScale, [Ref] PxVec3 linearImpulse, [Ref] PxVec3 angularImpulse);
};

[Prefix="physx::"]
interface PxRigidBodyFlags {
    void PxRigidBodyFlags(octet flags);
    boolean isSet(PxRigidBodyFlagEnum flag);
    void raise(PxRigidBodyFlagEnum flag);
    void clear(PxRigidBodyFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxRigidDynamic {
    void setKinematicTarget([Const, Ref] PxTransform destination);
    boolean getKinematicTarget([Ref] PxTransform target);
    boolean isSleeping();
    void setSleepThreshold(float threshold);
    float getSleepThreshold();
    void setStabilizationThreshold(float threshold);
    float getStabilizationThreshold();
    [Value] PxRigidDynamicLockFlags getRigidDynamicLockFlags();
    void setRigidDynamicLockFlag(PxRigidDynamicLockFlagEnum flag, boolean value);
    void setRigidDynamicLockFlags([Ref] PxRigidDynamicLockFlags flags);
    void setLinearVelocity([Const, Ref] PxVec3 linVel, optional boolean autowake);
    void setAngularVelocity([Const, Ref] PxVec3 angVel, optional boolean autowake);
    void setWakeCounter(float wakeCounterValue);
    float getWakeCounter();
    void wakeUp();
    void putToSleep();
    void setSolverIterationCounts(unsigned long minPositionIters, optional unsigned long minVelocityIters);
    float getContactReportThreshold();
    void setContactReportThreshold(float threshold);
};
PxRigidDynamic implements PxRigidBody;

[Prefix="physx::"]
interface PxRigidDynamicLockFlags {
    void PxRigidDynamicLockFlags(octet flags);
    boolean isSet(PxRigidDynamicLockFlagEnum flag);
    void raise(PxRigidDynamicLockFlagEnum flag);
    void clear(PxRigidDynamicLockFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxRigidStatic {
};
PxRigidStatic implements PxRigidActor;

[Prefix="physx::", NoDelete]
interface PxScene {
    boolean addActor([Ref] PxActor actor, [Const] optional PxBVHStructure bvhStructure);
    void removeActor([Ref] PxActor actor, optional boolean wakeOnLostTouch);
    boolean addAggregate([Ref] PxAggregate aggregate);
    void removeAggregate([Ref] PxAggregate aggregate, optional boolean wakeOnLostTouch);
    boolean addCollection([Const, Ref] PxCollection collection);
    float getWakeCounterResetValue();
    void shiftOrigin([Const, Ref] PxVec3 shift);
    boolean addArticulation([Ref] PxArticulationReducedCoordinate articulation);
    void removeArticulation([Ref] PxArticulationReducedCoordinate articulation, optional boolean wakeOnLostTouch);
    unsigned long getNbActors([Ref] PxActorTypeFlags types);
    unsigned long getNbSoftBodies();
    unsigned long getNbParticleSystems(PxParticleSolverTypeEnum type);
    unsigned long getNbArticulations();
    unsigned long getNbConstraints();
    unsigned long getNbAggregates();
    void setDominanceGroupPair(octet group1, octet group2, [Const, Ref] PxDominanceGroupPair dominance);
    PxCpuDispatcher getCpuDispatcher();
    octet createClient();
    void setSimulationEventCallback(PxSimulationEventCallback callback);
    PxSimulationEventCallback getSimulationEventCallback();
    void setFilterShaderData([Const] VoidPtr data, unsigned long dataSize);
    [Const] VoidPtr getFilterShaderData();
    unsigned long getFilterShaderDataSize();
    [Value] PxSimulationFilterShader getFilterShader();
    boolean resetFiltering([Ref] PxActor actor);
    PxPairFilteringModeEnum getKinematicKinematicFilteringMode();
    PxPairFilteringModeEnum getStaticKinematicFilteringMode();
    boolean simulate(float elapsedTime, optional PxBaseTask completionTask, optional VoidPtr scratchMemBlock, optional unsigned long scratchMemBlockSize, optional boolean controlSimulation);
    boolean advance(optional PxBaseTask completionTask);
    boolean collide(float elapsedTime, optional PxBaseTask completionTask, optional VoidPtr scratchMemBlock, optional unsigned long scratchMemBlockSize, optional boolean controlSimulation);
    boolean checkResults(optional boolean block);
    boolean fetchCollision(optional boolean block);
    boolean fetchResults(optional boolean block);
    void processCallbacks(PxBaseTask continuation);
    void fetchResultsParticleSystem();
    void flushSimulation(optional boolean sendPendingReports);
    void setGravity([Const, Ref] PxVec3 vec);
    [Value] PxVec3 getGravity();
    void setBounceThresholdVelocity(float t);
    float getBounceThresholdVelocity();
    void setCCDMaxPasses(unsigned long ccdMaxPasses);
    unsigned long getCCDMaxPasses();
    void setCCDMaxSeparation(float t);
    float getCCDMaxSeparation();
    void setCCDThreshold(float t);
    float getCCDThreshold();
    void setMaxBiasCoefficient(float t);
    float getMaxBiasCoefficient();
    void setFrictionOffsetThreshold(float t);
    float getFrictionOffsetThreshold();
    void setFrictionCorrelationDistance(float t);
    float getFrictionCorrelationDistance();
    PxFrictionTypeEnum getFrictionType();
    PxSolverTypeEnum getSolverType();
    boolean setVisualizationParameter(PxVisualizationParameterEnum param, float value);
    float getVisualizationParameter(PxVisualizationParameterEnum paramEnum);
    void setVisualizationCullingBox([Const, Ref] PxBounds3 box);
    [Value] PxBounds3 getVisualizationCullingBox();
    void getSimulationStatistics([Ref] PxSimulationStatistics stats);
    PxBroadPhaseTypeEnum getBroadPhaseType();
    boolean getBroadPhaseCaps([Ref] PxBroadPhaseCaps caps);
    unsigned long getNbBroadPhaseRegions();
    unsigned long getBroadPhaseRegions(PxBroadPhaseRegionInfo userBuffer, unsigned long bufferSize, optional unsigned long startIndex);
    unsigned long addBroadPhaseRegion([Const, Ref] PxBroadPhaseRegion region, optional boolean populateRegion);
    boolean removeBroadPhaseRegion(unsigned long handle);
    void lockRead([Const] optional DOMString file, optional unsigned long line);
    void unlockRead();
    void lockWrite([Const] optional DOMString file, optional unsigned long line);
    void unlockWrite();
    void setNbContactDataBlocks(unsigned long numBlocks);
    unsigned long getNbContactDataBlocksUsed();
    unsigned long getMaxNbContactDataBlocksUsed();
    unsigned long getContactReportStreamBufferSize();
    void setSolverBatchSize(unsigned long solverBatchSize);
    unsigned long getSolverBatchSize();
    void setSolverArticulationBatchSize(unsigned long solverBatchSize);
    unsigned long getSolverArticulationBatchSize();
    void release();
    void setFlag(PxSceneFlagEnum flag, boolean value);
    [Value] PxSceneFlags getFlags();
    void setLimits([Const, Ref] PxSceneLimits limits);
    [Value] PxSceneLimits getLimits();
    [Ref] PxPhysics getPhysics();
    unsigned long getTimestamp();
    attribute VoidPtr userData;
};
PxScene implements PxSceneSQSystem;

[Prefix="physx::"]
interface PxSceneDesc {
    void PxSceneDesc([Const, Ref] PxTolerancesScale scale);
    void setToDefault([Const, Ref] PxTolerancesScale scale);
    boolean isValid();
    [Value] attribute PxVec3 gravity;
    attribute PxSimulationEventCallback simulationEventCallback;
    [Const] attribute VoidPtr filterShaderData;
    attribute unsigned long filterShaderDataSize;
    [Value] attribute PxSimulationFilterShader filterShader;
    attribute PxPairFilteringModeEnum kineKineFilteringMode;
    attribute PxPairFilteringModeEnum staticKineFilteringMode;
    attribute PxBroadPhaseTypeEnum broadPhaseType;
    [Value] attribute PxSceneLimits limits;
    attribute PxFrictionTypeEnum frictionType;
    attribute PxSolverTypeEnum solverType;
    attribute float bounceThresholdVelocity;
    attribute float frictionOffsetThreshold;
    attribute float frictionCorrelationDistance;
    [Value] attribute PxSceneFlags flags;
    attribute PxCpuDispatcher cpuDispatcher;
    attribute VoidPtr userData;
    attribute unsigned long solverBatchSize;
    attribute unsigned long solverArticulationBatchSize;
    attribute unsigned long nbContactDataBlocks;
    attribute unsigned long maxNbContactDataBlocks;
    attribute float maxBiasCoefficient;
    attribute unsigned long contactReportStreamBufferSize;
    attribute unsigned long ccdMaxPasses;
    attribute float ccdThreshold;
    attribute float ccdMaxSeparation;
    attribute float wakeCounterResetValue;
    [Value] attribute PxBounds3 sanityBounds;
    attribute unsigned long gpuMaxNumPartitions;
    attribute unsigned long gpuMaxNumStaticPartitions;
    attribute unsigned long gpuComputeVersion;
    attribute unsigned long contactPairSlabSize;
    attribute PxPruningStructureTypeEnum staticStructure;
    attribute PxPruningStructureTypeEnum dynamicStructure;
    attribute unsigned long dynamicTreeRebuildRateHint;
    attribute PxDynamicTreeSecondaryPrunerEnum dynamicTreeSecondaryPruner;
    attribute PxBVHBuildStrategyEnum staticBVHBuildStrategy;
    attribute PxBVHBuildStrategyEnum dynamicBVHBuildStrategy;
    attribute unsigned long staticNbObjectsPerNode;
    attribute unsigned long dynamicNbObjectsPerNode;
    attribute PxSceneQueryUpdateModeEnum sceneQueryUpdateMode;
};

[Prefix="physx::"]
interface PxSceneFlags {
    void PxSceneFlags(unsigned long flags);
    boolean isSet(PxSceneFlagEnum flag);
    void raise(PxSceneFlagEnum flag);
    void clear(PxSceneFlagEnum flag);
};

[Prefix="physx::"]
interface PxSceneLimits {
    void PxSceneLimits();
    void setToDefault();
    boolean isValid();
    attribute unsigned long maxNbActors;
    attribute unsigned long maxNbBodies;
    attribute unsigned long maxNbStaticShapes;
    attribute unsigned long maxNbDynamicShapes;
    attribute unsigned long maxNbAggregates;
    attribute unsigned long maxNbConstraints;
    attribute unsigned long maxNbRegions;
    attribute unsigned long maxNbBroadPhaseOverlaps;
};

[Prefix="physx::", NoDelete]
interface PxSceneQuerySystemBase {
    void setDynamicTreeRebuildRateHint(unsigned long dynamicTreeRebuildRateHint);
    unsigned long getDynamicTreeRebuildRateHint();
    void forceRebuildDynamicTree(unsigned long prunerIndex);
    void setUpdateMode(PxSceneQueryUpdateModeEnum updateMode);
    PxSceneQueryUpdateModeEnum getUpdateMode();
    unsigned long getStaticTimestamp();
    void flushUpdates();
    boolean raycast([Const, Ref] PxVec3 origin, [Const, Ref] PxVec3 unitDir, float distance, [Ref] PxRaycastCallback hitCall, [Ref] optional PxHitFlags hitFlags, [Const, Ref] optional PxQueryFilterData filterData);
    boolean sweep([Const, Ref] PxGeometry geometry, [Const, Ref] PxTransform pose, [Const, Ref] PxVec3 unitDir, float distance, [Ref] PxSweepCallback hitCall, [Ref] optional PxHitFlags hitFlags, [Const, Ref] optional PxQueryFilterData filterData);
    boolean overlap([Const, Ref] PxGeometry geometry, [Const, Ref] PxTransform pose, [Ref] PxOverlapCallback hitCall, [Const, Ref] optional PxQueryFilterData filterData);
};

[Prefix="physx::", NoDelete]
interface PxSceneSQSystem {
    void setSceneQueryUpdateMode(PxSceneQueryUpdateModeEnum updateMode);
    PxSceneQueryUpdateModeEnum getSceneQueryUpdateMode();
    unsigned long getSceneQueryStaticTimestamp();
    void flushQueryUpdates();
    void forceDynamicTreeRebuild(boolean rebuildStaticStructure, boolean rebuildDynamicStructure);
    PxPruningStructureTypeEnum getStaticStructure();
    PxPruningStructureTypeEnum getDynamicStructure();
    void sceneQueriesUpdate(optional PxBaseTask completionTask, optional boolean controlSimulation);
    boolean checkQueries(optional boolean block);
    boolean fetchQueries(optional boolean block);
};
PxSceneSQSystem implements PxSceneQuerySystemBase;

[Prefix="physx::"]
interface PxSerialization {
    static boolean isSerializable([Ref] PxCollection collection, [Ref] PxSerializationRegistry sr, [Const] optional PxCollection externalReferences);
    static void complete([Ref] PxCollection collection, [Ref] PxSerializationRegistry sr, [Const] optional PxCollection exceptFor, optional boolean followJoints);
    static void createSerialObjectIds([Ref] PxCollection collection, unsigned long long base);
    static PxCollection createCollectionFromXml([Ref] PxInputData inputData, [Ref] PxCooking cooking, [Ref] PxSerializationRegistry sr, [Const] optional PxCollection externalRefs);
    static PxCollection createCollectionFromBinary(VoidPtr memBlock, [Ref] PxSerializationRegistry sr, [Const] optional PxCollection externalRefs);
    static boolean serializeCollectionToXml([Ref] PxOutputStream outputStream, [Ref] PxCollection collection, [Ref] PxSerializationRegistry sr, optional PxCooking cooking, [Const] optional PxCollection externalRefs);
    static boolean serializeCollectionToBinary([Ref] PxOutputStream outputStream, [Ref] PxCollection collection, [Ref] PxSerializationRegistry sr, [Const] optional PxCollection externalRefs, optional boolean exportNames);
    static PxSerializationRegistry createSerializationRegistry([Ref] PxPhysics physics);
};

[Prefix="physx::", NoDelete]
interface PxSerializationRegistry {
    void release();
};

[Prefix="physx::", NoDelete]
interface PxShape {
    PxGeometryTypeEnum getGeometryType();
    void setGeometry([Const, Ref] PxGeometry geometry);
    [Const, Ref] PxGeometry getGeometry();
    PxRigidActor getActor();
    void setMaterials(PxMaterialPtr materials, unsigned short materialCount);
    unsigned short getNbMaterials();
    unsigned long getMaterials(PxMaterialPtr userBuffer, unsigned long bufferSize, unsigned long startIndex);
    PxBaseMaterial getMaterialFromInternalFaceIndex(unsigned long faceIndex);
    void setContactOffset(float contactOffset);
    float getContactOffset();
    void setRestOffset(float restOffset);
    float getRestOffset();
    void setTorsionalPatchRadius(float radius);
    float getTorsionalPatchRadius();
    void setMinTorsionalPatchRadius(float radius);
    float getMinTorsionalPatchRadius();
    void setFlag(PxShapeFlagEnum flag, boolean value);
    void setFlags([Ref] PxShapeFlags inFlags);
    [Value] PxShapeFlags getFlags();
    boolean isExclusive();
    void setName([Const] DOMString name);
    [Const] DOMString getName();
    void setLocalPose([Const, Ref] PxTransform pose);
    [Value] PxTransform getLocalPose();
    void setSimulationFilterData([Const, Ref] PxFilterData data);
    [Value] PxFilterData getSimulationFilterData();
    void setQueryFilterData([Const, Ref] PxFilterData data);
    [Value] PxFilterData getQueryFilterData();
    attribute VoidPtr userData;
};
PxShape implements PxRefCounted;

[Prefix="physx::"]
interface PxShapeExt {
    [Value] static PxTransform getGlobalPose([Const, Ref] PxShape shape, [Const, Ref] PxRigidActor actor);
    static unsigned long raycast([Const, Ref] PxShape shape, [Const, Ref] PxRigidActor actor, [Const, Ref] PxVec3 rayOrigin, [Const, Ref] PxVec3 rayDir, float maxDist, [Ref] PxHitFlags hitFlags, unsigned long maxHits, PxRaycastHit rayHits);
    static boolean overlap([Const, Ref] PxShape shape, [Const, Ref] PxRigidActor actor, [Const, Ref] PxGeometry otherGeom, [Const, Ref] PxTransform otherGeomPose);
    static boolean sweep([Const, Ref] PxShape shape, [Const, Ref] PxRigidActor actor, [Const, Ref] PxVec3 unitDir, float distance, [Const, Ref] PxGeometry otherGeom, [Const, Ref] PxTransform otherGeomPose, [Ref] PxSweepHit sweepHit, [Ref] PxHitFlags hitFlags);
    [Value] static PxBounds3 getWorldBounds([Const, Ref] PxShape shape, [Const, Ref] PxRigidActor actor, optional float inflation);
};

[Prefix="physx::"]
interface PxShapeFlags {
    void PxShapeFlags(octet flags);
    boolean isSet(PxShapeFlagEnum flag);
    void raise(PxShapeFlagEnum flag);
    void clear(PxShapeFlagEnum flag);
};

[Prefix="physx::"]
interface PxSimpleTriangleMesh {
    void PxSimpleTriangleMesh();
    void setToDefault();
    boolean isValid();
    [Value] attribute PxBoundedData points;
    [Value] attribute PxBoundedData triangles;
    [Value] attribute PxMeshFlags flags;
};

[Prefix="physx::"]
interface PxSimulationEventCallback {
};

[JSImplementation="SimpleSimulationEventCallback"]
interface PxSimulationEventCallbackImpl {
    void PxSimulationEventCallbackImpl();
    void onConstraintBreak(PxConstraintInfo constraints, unsigned long count);
    void onWake(PxActorPtr actors, unsigned long count);
    void onSleep(PxActorPtr actors, unsigned long count);
    void onContact([Const, Ref] PxContactPairHeader pairHeader, [Const] PxContactPair pairs, unsigned long nbPairs);
    void onTrigger(PxTriggerPair pairs, unsigned long count);
};

[Prefix="physx::"]
interface PxSimulationFilterShader {
};

[Prefix="physx::"]
interface PxSimulationStatistics {
    attribute unsigned long nbActiveConstraints;
    attribute unsigned long nbActiveDynamicBodies;
    attribute unsigned long nbActiveKinematicBodies;
    attribute unsigned long nbStaticBodies;
    attribute unsigned long nbDynamicBodies;
    attribute unsigned long nbKinematicBodies;
    attribute unsigned long[] nbShapes;
    attribute unsigned long nbAggregates;
    attribute unsigned long nbArticulations;
    attribute unsigned long nbAxisSolverConstraints;
    attribute unsigned long compressedContactSize;
    attribute unsigned long requiredContactConstraintMemory;
    attribute unsigned long peakConstraintMemory;
    attribute unsigned long nbDiscreteContactPairsTotal;
    attribute unsigned long nbDiscreteContactPairsWithCacheHits;
    attribute unsigned long nbDiscreteContactPairsWithContacts;
    attribute unsigned long nbNewPairs;
    attribute unsigned long nbLostPairs;
    attribute unsigned long nbNewTouches;
    attribute unsigned long nbLostTouches;
    attribute unsigned long nbPartitions;
    attribute unsigned long nbBroadPhaseAdds;
    attribute unsigned long nbBroadPhaseRemoves;
};

[Prefix="physx::"]
interface PxSpatialForce {
    [Value] attribute PxVec3 force;
    [Value] attribute PxVec3 torque;
};

[Prefix="physx::"]
interface PxSpatialVelocity {
    [Value] attribute PxVec3 linear;
    [Value] attribute PxVec3 angular;
};

[Prefix="physx::"]
interface PxSphereGeometry {
    void PxSphereGeometry(float ir);
};
PxSphereGeometry implements PxGeometry;

[Prefix="physx::"]
interface PxSphericalJoint {
    void setLimitCone([Const, Ref] PxJointLimitCone limitCone);
    float getSwingYAngle();
    float getSwingZAngle();
    void setSphericalJointFlags([Ref] PxSphericalJointFlags flags);
    void setSphericalJointFlag(PxSphericalJointFlagEnum flag, boolean value);
    [Value] PxSphericalJointFlags getSphericalJointFlags();
    void setProjectionLinearTolerance(float tolerance);
    float getProjectionLinearTolerance();
};
PxSphericalJoint implements PxJoint;

[Prefix="physx::"]
interface PxSphericalJointFlags {
    void PxSphericalJointFlags(unsigned short flags);
    boolean isSet(PxSphericalJointFlagEnum flag);
    void raise(PxSphericalJointFlagEnum flag);
    void clear(PxSphericalJointFlagEnum flag);
};

[Prefix="physx::"]
interface PxSpring {
    void PxSpring(float stiffness, float damping);
    attribute float stiffness;
    attribute float damping;
};

[Prefix="physx::"]
interface PxStridedData {
    attribute unsigned long stride;
    [Const] attribute VoidPtr data;
};

interface PxSweepBuffer10 {
    void PxSweepBuffer10();
    unsigned long getNbAnyHits();
    [Const, Ref] PxSweepHit getAnyHit(unsigned long index);
    unsigned long getNbTouches();
    [Const] PxSweepHit getTouches();
    [Const, Ref] PxSweepHit getTouch(unsigned long index);
    unsigned long getMaxNbTouches();
    [Value] attribute PxSweepHit block;
    attribute boolean hasBlock;
};
PxSweepBuffer10 implements PxSweepCallback;

[Prefix="physx::"]
interface PxSweepCallback {
    boolean hasAnyHits();
};

[Prefix="physx::"]
interface PxSweepHit {
    void PxSweepHit();
    attribute PxRigidActor actor;
    attribute PxShape shape;
};
PxSweepHit implements PxGeomSweepHit;

[Prefix="physx::"]
interface PxTolerancesScale {
    void PxTolerancesScale();
};

[NoDelete]
interface PxTopLevelFunctions {
    [Value] static PxSimulationFilterShader DefaultFilterShader();
    static void setupPassThroughFilterShader(PxSceneDesc sceneDesc, PassThroughFilterShader filterShader);
    static PxControllerManager CreateControllerManager([Ref] PxScene scene, optional boolean lockingEnabled);
    static PxFoundation CreateFoundation(unsigned long version, [Ref] PxDefaultAllocator allocator, [Ref] PxErrorCallback errorCallback);
    static PxPhysics CreatePhysics(unsigned long version, [Ref] PxFoundation foundation, [Const, Ref] PxTolerancesScale params, optional PxPvd pvd);
    static PxDefaultCpuDispatcher DefaultCpuDispatcherCreate(unsigned long numThreads);
    static boolean InitExtensions([Ref] PxPhysics physics);
    static void CloseExtensions();
    static PxPvd CreatePvd([Ref] PxFoundation foundation);
    static PxD6Joint D6JointCreate([Ref] PxPhysics physics, PxRigidActor actor0, [Ref] PxTransform localFrame0, PxRigidActor actor1, [Ref] PxTransform localFrame1);
    static PxDistanceJoint DistanceJointCreate([Ref] PxPhysics physics, PxRigidActor actor0, [Ref] PxTransform localFrame0, PxRigidActor actor1, [Ref] PxTransform localFrame1);
    static PxFixedJoint FixedJointCreate([Ref] PxPhysics physics, PxRigidActor actor0, [Ref] PxTransform localFrame0, PxRigidActor actor1, [Ref] PxTransform localFrame1);
    static PxPrismaticJoint PrismaticJointCreate([Ref] PxPhysics physics, PxRigidActor actor0, [Ref] PxTransform localFrame0, PxRigidActor actor1, [Ref] PxTransform localFrame1);
    static PxRevoluteJoint RevoluteJointCreate([Ref] PxPhysics physics, PxRigidActor actor0, [Ref] PxTransform localFrame0, PxRigidActor actor1, [Ref] PxTransform localFrame1);
    static PxSphericalJoint SphericalJointCreate([Ref] PxPhysics physics, PxRigidActor actor0, [Ref] PxTransform localFrame0, PxRigidActor actor1, [Ref] PxTransform localFrame1);
    static PxConvexMesh CreateConvexMesh([Const, Ref] PxCookingParams params, [Const, Ref] PxConvexMeshDesc desc);
    static PxTriangleMesh CreateTriangleMesh([Const, Ref] PxCookingParams params, [Const, Ref] PxTriangleMeshDesc desc);
    static PxHeightField CreateHeightField([Const, Ref] PxHeightFieldDesc desc);
    static PxCooking CreateCooking(unsigned long version, [Ref] PxFoundation foundation, [Const, Ref] PxCookingParams scale);
    static readonly attribute unsigned long PHYSICS_VERSION;
};

[Prefix="physx::"]
interface PxTransform {
    void PxTransform();
    void PxTransform(PxIDENTITYEnum r);
    void PxTransform([Const, Ref] PxVec3 p0, [Const, Ref] PxQuat q0);
    [Value] attribute PxQuat q;
    [Value] attribute PxVec3 p;
};

[Prefix="physx::"]
interface PxTriangle {
    void PxTriangle();
    void PxTriangle([Const, Ref] PxVec3 p0, [Const, Ref] PxVec3 p1, [Const, Ref] PxVec3 p2);
    void normal([Ref] PxVec3 normal);
    void denormalizedNormal([Ref] PxVec3 normal);
    float area();
    [Value] PxVec3 pointFromUV(float u, float v);
};

[Prefix="physx::", NoDelete]
interface PxTriangleMesh {
    unsigned long getNbVertices();
    [Const] PxVec3 getVertices();
    PxVec3 getVerticesForModification();
    [Value] PxBounds3 refitBVH();
    unsigned long getNbTriangles();
    [Const] VoidPtr getTriangles();
    [Value] PxTriangleMeshFlags getTriangleMeshFlags();
    [Const, Value] PxU32ConstPtr getTrianglesRemap();
    unsigned short getTriangleMaterialIndex(unsigned long triangleIndex);
    [Value] PxBounds3 getLocalBounds();
};
PxTriangleMesh implements PxRefCounted;

[Prefix="physx::"]
interface PxTriangleMeshDesc {
    void PxTriangleMeshDesc();
    [Value] attribute PxU16StridedData materialIndices;
};
PxTriangleMeshDesc implements PxSimpleTriangleMesh;

[Prefix="physx::"]
interface PxTriangleMeshFlags {
    void PxTriangleMeshFlags(octet flags);
    boolean isSet(PxTriangleMeshFlagEnum flag);
    void raise(PxTriangleMeshFlagEnum flag);
    void clear(PxTriangleMeshFlagEnum flag);
};

[Prefix="physx::"]
interface PxTriangleMeshGeometry {
    void PxTriangleMeshGeometry(PxTriangleMesh mesh, [Const, Ref] optional PxMeshScale scaling, [Ref] optional PxMeshGeometryFlags flags);
    boolean isValid();
};
PxTriangleMeshGeometry implements PxGeometry;

[Prefix="physx::"]
interface PxTriggerPair {
    attribute PxShape triggerShape;
    attribute PxActor triggerActor;
    attribute PxShape otherShape;
    attribute PxActor otherActor;
    attribute PxPairFlagEnum status;
    [Value] attribute PxTriggerPairFlags flags;
};

[Prefix="physx::"]
interface PxTriggerPairFlags {
    void PxTriggerPairFlags(octet flags);
    boolean isSet(PxTriggerPairFlagEnum flag);
    void raise(PxTriggerPairFlagEnum flag);
    void clear(PxTriggerPairFlagEnum flag);
};

interface PxU16ConstPtr {
};

interface PxU16Ptr {
};
PxU16Ptr implements PxU16ConstPtr;

interface PxU16StridedData {
    attribute unsigned long stride;
    [Const, Value] attribute PxU16ConstPtr data;
};

interface PxU32ConstPtr {
};

interface PxU32Ptr {
};
PxU32Ptr implements PxU32ConstPtr;

interface PxU8ConstPtr {
};

interface PxU8Ptr {
};
PxU8Ptr implements PxU8ConstPtr;

[Prefix="physx::", NoDelete]
interface PxUserControllerHitReport {
    void onShapeHit([Const, Ref] PxControllerShapeHit hit);
    void onControllerHit([Const, Ref] PxControllersHit hit);
    void onObstacleHit([Const, Ref] PxControllerObstacleHit hit);
};

[JSImplementation="PxUserControllerHitReport"]
interface PxUserControllerHitReportImpl {
    void PxUserControllerHitReportImpl();
    void onShapeHit([Const, Ref] PxControllerShapeHit hit);
    void onControllerHit([Const, Ref] PxControllersHit hit);
    void onObstacleHit([Const, Ref] PxControllerObstacleHit hit);
};

[Prefix="physx::"]
interface PxVec3 {
    void PxVec3();
    void PxVec3(float x, float y, float z);
    boolean isZero();
    boolean isFinite();
    boolean isNormalized();
    float magnitudeSquared();
    float magnitude();
    float dot([Const, Ref] PxVec3 v);
    [Value] PxVec3 cross([Const, Ref] PxVec3 v);
    [Value] PxVec3 getNormalized();
    float normalize();
    float normalizeSafe();
    float normalizeFast();
    [Value] PxVec3 multiply([Const, Ref] PxVec3 a);
    [Value] PxVec3 minimum([Const, Ref] PxVec3 v);
    float minElement();
    [Value] PxVec3 maximum([Const, Ref] PxVec3 v);
    float maxElement();
    [Value] PxVec3 abs();
    attribute float x;
    attribute float y;
    attribute float z;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleAckermannParams {
    void PxVehicleAckermannParams();
    boolean isValid([Const, Ref] PxVehicleAxleDescription axleDesc);
    [Value] PxVehicleAckermannParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    attribute unsigned long[] wheelIds;
    attribute float wheelBase;
    attribute float trackWidth;
    attribute float strength;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleAntiRollForceParams {
    void PxVehicleAntiRollForceParams();
    [Value] PxVehicleAntiRollForceParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid([Const, Ref] PxVehicleAxleDescription axleDesc);
    attribute unsigned long wheel0;
    attribute unsigned long wheel1;
    attribute float stiffness;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleAntiRollTorque {
    void PxVehicleAntiRollTorque();
    void setToDefault();
    [Value] attribute PxVec3 antiRollTorque;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleAutoboxParams {
    void PxVehicleAutoboxParams();
    [Value] PxVehicleAutoboxParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid([Const, Ref] PxVehicleGearboxParams gearboxParams);
    attribute float[] upRatios;
    attribute float[] downRatios;
    attribute float latency;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleAutoboxState {
    void PxVehicleAutoboxState();
    void setToDefault();
    attribute float timeSinceLastShift;
    attribute boolean activeAutoboxGearShift;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleAxleDescription {
    void PxVehicleAxleDescription();
    void setToDefault();
    unsigned long getNbWheelsOnAxle(unsigned long i);
    unsigned long getWheelOnAxle(unsigned long j, unsigned long i);
    unsigned long getAxle(unsigned long wheelId);
    boolean isValid();
    attribute unsigned long nbAxles;
    attribute unsigned long[] nbWheelsPerAxle;
    attribute unsigned long[] axleToWheelIds;
    attribute unsigned long[] wheelIdsInAxleOrder;
    attribute unsigned long nbWheels;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleBrakeCommandResponseParams {
    void PxVehicleBrakeCommandResponseParams();
    [Value] PxVehicleBrakeCommandResponseParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid([Const, Ref] PxVehicleAxleDescription axleDesc);
};
PxVehicleBrakeCommandResponseParams implements PxVehicleCommandResponseParams;

[Prefix="physx::vehicle2::"]
interface PxVehicleClutchCommandResponseParams {
    void PxVehicleClutchCommandResponseParams();
    [Value] PxVehicleClutchCommandResponseParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid();
    attribute float maxResponse;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleClutchCommandResponseState {
    void PxVehicleClutchCommandResponseState();
    void setToDefault();
    attribute float normalisedCommandResponse;
    attribute float commandResponse;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleClutchParams {
    void PxVehicleClutchParams();
    [Value] PxVehicleClutchParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid();
    attribute PxVehicleClutchAccuracyModeEnum accuracyMode;
    attribute unsigned long estimateIterations;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleClutchSlipState {
    void PxVehicleClutchSlipState();
    void setToDefault();
    attribute float clutchSlip;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleCommandNonLinearResponseParams {
    void PxVehicleCommandNonLinearResponseParams();
    void clear();
    boolean addResponse([Const, Ref] PxVehicleCommandValueResponseTable commandValueSpeedResponses);
    attribute float[] speedResponses;
    attribute short nbSpeedResponses;
    attribute short[] speedResponsesPerCommandValue;
    attribute short[] nbSpeedRenponsesPerCommandValue;
    attribute float[] commandValues;
    attribute short nbCommandValues;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleCommandResponseParams {
    void PxVehicleCommandResponseParams();
    [Value] attribute PxVehicleCommandNonLinearResponseParams nonlinearResponse;
    attribute float[] wheelResponseMultipliers;
    attribute float maxResponse;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleCommandState {
    void PxVehicleCommandState();
    void setToDefault();
    attribute float[] brakes;
    attribute unsigned long nbBrakes;
    attribute float throttle;
    attribute float steer;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleCommandValueResponseTable {
    void PxVehicleCommandValueResponseTable();
    attribute float commandValue;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleComponent {
};

[Prefix="physx::vehicle2::"]
interface PxVehicleComponentSequence {
    void PxVehicleComponentSequence();
    boolean add(PxVehicleComponent component);
    octet beginSubstepGroup(optional octet nbSubSteps);
    void endSubstepGroup();
    void setSubsteps(octet subGroupHandle, octet nbSteps);
    void update(float dt, [Const, Ref] PxVehicleSimulationContext context);
};

[Prefix="physx::vehicle2::"]
interface PxVehicleConstraintConnector {
    void PxVehicleConstraintConnector();
    void PxVehicleConstraintConnector(PxVehiclePhysXConstraintState vehicleConstraintState);
    void setConstraintState(PxVehiclePhysXConstraintState constraintState);
    void getConstantBlock();
};
PxVehicleConstraintConnector implements PxConstraintConnector;

[Prefix="physx::vehicle2::"]
interface PxVehicleDifferentialState {
    void PxVehicleDifferentialState();
    void setToDefault();
    attribute unsigned long[] connectedWheels;
    attribute unsigned long nbConnectedWheels;
    attribute float[] torqueRatiosAllWheels;
    attribute float[] aveWheelSpeedContributionAllWheels;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleDirectDriveThrottleCommandResponseParams {
    void PxVehicleDirectDriveThrottleCommandResponseParams();
    [Value] PxVehicleDirectDriveThrottleCommandResponseParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid([Const, Ref] PxVehicleAxleDescription axleDesc);
};
PxVehicleDirectDriveThrottleCommandResponseParams implements PxVehicleCommandResponseParams;

[Prefix="physx::vehicle2::"]
interface PxVehicleDirectDriveTransmissionCommandState {
    void PxVehicleDirectDriveTransmissionCommandState();
    void setToDefault();
    attribute PxVehicleDirectDriveTransmissionCommandStateEnum gear;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleEngineDriveThrottleCommandResponseState {
    void PxVehicleEngineDriveThrottleCommandResponseState();
    void setToDefault();
    attribute float commandResponse;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleEngineDriveTransmissionCommandState {
    void PxVehicleEngineDriveTransmissionCommandState();
    void setToDefault();
    attribute float clutch;
    attribute unsigned long targetGear;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleEngineParams {
    void PxVehicleEngineParams();
    [Value] PxVehicleEngineParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid();
    [Value] attribute PxVehicleTorqueCurveLookupTable torqueCurve;
    attribute float moi;
    attribute float peakTorque;
    attribute float idleOmega;
    attribute float maxOmega;
    attribute float dampingRateFullThrottle;
    attribute float dampingRateZeroThrottleClutchEngaged;
    attribute float dampingRateZeroThrottleClutchDisengaged;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleEngineState {
    void PxVehicleEngineState();
    void setToDefault();
    attribute float rotationSpeed;
};

interface PxVehicleFixedSizeLookupTableFloat_3 {
    void PxVehicleFixedSizeLookupTableFloat_3();
    boolean addPair(float x, float y);
    float interpolate(float x);
    void clear();
    boolean isValid();
};

interface PxVehicleFixedSizeLookupTableVec3_3 {
    void PxVehicleFixedSizeLookupTableVec3_3();
    boolean addPair(float x, [Const, Ref] PxVec3 y);
    [Value] PxVec3 interpolate(float x);
    void clear();
    boolean isValid();
};

[Prefix="physx::vehicle2::"]
interface PxVehicleFourWheelDriveDifferentialParams {
    void PxVehicleFourWheelDriveDifferentialParams();
    void setToDefault();
    [Value] PxVehicleFourWheelDriveDifferentialParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    attribute unsigned long[] frontWheelIds;
    attribute unsigned long[] rearWheelIds;
    attribute float frontBias;
    attribute float frontTarget;
    attribute float rearBias;
    attribute float rearTarget;
    attribute float centerBias;
    attribute float centerTarget;
    attribute float rate;
};
PxVehicleFourWheelDriveDifferentialParams implements PxVehicleMultiWheelDriveDifferentialParams;

[Prefix="physx::vehicle2::"]
interface PxVehicleFrame {
    void PxVehicleFrame();
    void setToDefault();
    [Value] PxMat33 getFrame();
    boolean isValid();
    attribute PxVehicleAxesEnum lngAxis;
    attribute PxVehicleAxesEnum latAxis;
    attribute PxVehicleAxesEnum vrtAxis;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleGearboxParams {
    void PxVehicleGearboxParams();
    [Value] PxVehicleGearboxParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid();
    attribute unsigned long neutralGear;
    attribute float[] ratios;
    attribute float finalRatio;
    attribute unsigned long nbRatios;
    attribute float switchTime;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleGearboxState {
    void PxVehicleGearboxState();
    void setToDefault();
    attribute unsigned long currentGear;
    attribute unsigned long targetGear;
    attribute float gearSwitchTime;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleMultiWheelDriveDifferentialParams {
    void PxVehicleMultiWheelDriveDifferentialParams();
    void setToDefault();
    [Value] PxVehicleMultiWheelDriveDifferentialParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid([Const, Ref] PxVehicleAxleDescription axleDesc);
    attribute float[] torqueRatios;
    attribute float[] aveWheelSpeedRatios;
};

[Prefix="physx::vehicle2::"]
interface PxVehiclePhysXActor {
    void setToDefault();
    attribute PxRigidBody rigidBody;
    attribute PxShape[] wheelShapes;
};

[Prefix="physx::vehicle2::"]
interface PxVehiclePhysXConstraintState {
    void PxVehiclePhysXConstraintState();
    void setToDefault();
    attribute boolean[] tireActiveStatus;
    [Value] attribute PxVec3[] tireLinears;
    [Value] attribute PxVec3[] tireAngulars;
    attribute float[] tireDamping;
    attribute boolean suspActiveStatus;
    [Value] attribute PxVec3 suspLinear;
    [Value] attribute PxVec3 suspAngular;
    attribute float suspGeometricError;
    attribute float restitution;
};

[Prefix="physx::vehicle2::"]
interface PxVehiclePhysXConstraints {
    void setToDefault();
    [Value] attribute PxVehiclePhysXConstraintState[] constraintStates;
    attribute PxConstraint[] constraints;
    attribute PxVehicleConstraintConnector[] constraintConnectors;
};

[Prefix="physx::vehicle2::"]
interface PxVehiclePhysXMaterialFriction {
    void PxVehiclePhysXMaterialFriction();
    boolean isValid();
    [Const] attribute PxMaterial material;
    attribute float friction;
};

[Prefix="physx::vehicle2::"]
interface PxVehiclePhysXMaterialFrictionParams {
    boolean isValid();
    attribute PxVehiclePhysXMaterialFriction materialFrictions;
    attribute unsigned long nbMaterialFrictions;
    attribute float defaultFriction;
};

[Prefix="physx::vehicle2::"]
interface PxVehiclePhysXRoadGeometryQueryParams {
    [Value] PxVehiclePhysXRoadGeometryQueryParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid();
    attribute PxVehiclePhysXRoadGeometryQueryTypeEnum roadGeometryQueryType;
    [Value] attribute PxQueryFilterData filterData;
    attribute PxQueryFilterCallback filterCallback;
};

[Prefix="physx::vehicle2::", NoDelete]
interface PxVehiclePhysXSimulationContext {
    void PxVehiclePhysXSimulationContext();
    [Value] PxVehiclePhysXSimulationContext transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    [Const] attribute PxConvexMesh physxUnitCylinderSweepMesh;
    [Const] attribute PxScene physxScene;
    attribute PxVehiclePhysXActorUpdateModeEnum physxActorUpdateMode;
    attribute float physxActorWakeCounterResetValue;
    attribute float physxActorWakeCounterThreshold;
};
PxVehiclePhysXSimulationContext implements PxVehicleSimulationContext;

[Prefix="physx::vehicle2::"]
interface PxVehiclePhysXSteerState {
    void setToDefault();
    attribute float previousSteerCommand;
};

[Prefix="physx::vehicle2::"]
interface PxVehiclePhysXSuspensionLimitConstraintParams {
    [Value] PxVehiclePhysXSuspensionLimitConstraintParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid();
    attribute float restitution;
    attribute PxVehiclePhysXSuspensionLimitConstraintParamsDirectionSpecifierEnum directionForSuspensionLimitConstraint;
};

[Prefix="physx::vehicle2::", NoDelete]
interface PxVehiclePvdContext {
};

[Prefix="physx::vehicle2::"]
interface PxVehicleRigidBodyParams {
    void PxVehicleRigidBodyParams();
    [Value] PxVehicleRigidBodyParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid();
    attribute float mass;
    [Value] attribute PxVec3 moi;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleRigidBodyState {
    void PxVehicleRigidBodyState();
    void setToDefault();
    float getVerticalSpeed([Const, Ref] PxVehicleFrame frame);
    float getLateralSpeed([Const, Ref] PxVehicleFrame frame);
    float getLongitudinalSpeed([Const, Ref] PxVehicleFrame frame);
    [Value] attribute PxTransform pose;
    [Value] attribute PxVec3 linearVelocity;
    [Value] attribute PxVec3 angularVelocity;
    [Value] attribute PxVec3 previousLinearVelocity;
    [Value] attribute PxVec3 previousAngularVelocity;
    [Value] attribute PxVec3 externalForce;
    [Value] attribute PxVec3 externalTorque;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleRoadGeometryState {
    void PxVehicleRoadGeometryState();
    void setToDefault();
    [Value] attribute PxPlane plane;
    attribute float friction;
    [Value] attribute PxVec3 velocity;
    attribute boolean hitState;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleScale {
    void PxVehicleScale();
    void setToDefault();
    boolean isValid();
    attribute float scale;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleSimulationContext {
    void PxVehicleSimulationContext();
    PxVehicleSimulationContextTypeEnum getType();
    void setToDefault();
    [Value] PxVehicleSimulationContext transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    [Value] attribute PxVec3 gravity;
    [Value] attribute PxVehicleFrame frame;
    [Value] attribute PxVehicleScale scale;
    [Value] attribute PxVehicleTireSlipParams tireSlipParams;
    [Value] attribute PxVehicleTireStickyParams tireStickyParams;
    attribute float thresholdForwardSpeedForWheelAngleIntegration;
    [Value] attribute PxVehiclePvdContext pvdContext;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleSteerCommandResponseParams {
    void PxVehicleSteerCommandResponseParams();
    [Value] PxVehicleSteerCommandResponseParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid([Const, Ref] PxVehicleAxleDescription axleDesc);
};
PxVehicleSteerCommandResponseParams implements PxVehicleCommandResponseParams;

[Prefix="physx::vehicle2::"]
interface PxVehicleSuspensionComplianceParams {
    void PxVehicleSuspensionComplianceParams();
    [Value] PxVehicleSuspensionComplianceParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid();
    [Value] attribute PxVehicleFixedSizeLookupTableFloat_3 wheelToeAngle;
    [Value] attribute PxVehicleFixedSizeLookupTableFloat_3 wheelCamberAngle;
    [Value] attribute PxVehicleFixedSizeLookupTableVec3_3 suspForceAppPoint;
    [Value] attribute PxVehicleFixedSizeLookupTableVec3_3 tireForceAppPoint;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleSuspensionComplianceState {
    void PxVehicleSuspensionComplianceState();
    void setToDefault();
    attribute float toe;
    attribute float camber;
    [Value] attribute PxVec3 tireForceAppPoint;
    [Value] attribute PxVec3 suspForceAppPoint;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleSuspensionForce {
    void PxVehicleSuspensionForce();
    void setToDefault();
    [Value] attribute PxVec3 force;
    [Value] attribute PxVec3 torque;
    attribute float normalForce;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleSuspensionForceParams {
    void PxVehicleSuspensionForceParams();
    [Value] PxVehicleSuspensionForceParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid();
    attribute float stiffness;
    attribute float damping;
    attribute float sprungMass;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleSuspensionParams {
    void PxVehicleSuspensionParams();
    [Value] PxVehicleSuspensionParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid();
    [Value] attribute PxTransform suspensionAttachment;
    [Value] attribute PxVec3 suspensionTravelDir;
    attribute float suspensionTravelDist;
    [Value] attribute PxTransform wheelAttachment;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleSuspensionState {
    void PxVehicleSuspensionState();
    void setToDefault(float _jounce, float _separation);
    attribute float jounce;
    attribute float jounceSpeed;
    attribute float separation;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleSuspensionStateCalculationParams {
    void PxVehicleSuspensionStateCalculationParams();
    [Value] PxVehicleSuspensionStateCalculationParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid();
    attribute PxVehicleSuspensionJounceCalculationTypeEnum suspensionJounceCalculationType;
    attribute boolean limitSuspensionExpansionVelocity;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleTankDriveDifferentialParams {
    void PxVehicleTankDriveDifferentialParams();
    void setToDefault();
    unsigned long getNbWheelsInTrack(unsigned long i);
    [Value] PxU32ConstPtr getWheelsInTrack(unsigned long i);
    unsigned long getWheelInTrack(unsigned long j, unsigned long i);
    unsigned long getThrustControllerIndex(unsigned long i);
    [Value] PxVehicleTankDriveDifferentialParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    attribute unsigned long nbTracks;
    attribute unsigned long[] thrustIdPerTrack;
    attribute unsigned long[] nbWheelsPerTrack;
    attribute unsigned long[] trackToWheelIds;
    attribute unsigned long[] wheelIdsInTrackOrder;
    attribute unsigned long nbWheelsInTracks;
};
PxVehicleTankDriveDifferentialParams implements PxVehicleMultiWheelDriveDifferentialParams;

[Prefix="physx::vehicle2::"]
interface PxVehicleTankDriveTransmissionCommandState {
    void PxVehicleTankDriveTransmissionCommandState();
    void setToDefault();
    attribute float[] thrusts;
};
PxVehicleTankDriveTransmissionCommandState implements PxVehicleEngineDriveTransmissionCommandState;

[Prefix="physx::vehicle2::"]
interface PxVehicleTireAxisStickyParams {
    void PxVehicleTireAxisStickyParams();
    [Value] PxVehicleTireAxisStickyParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid();
    attribute float thresholdSpeed;
    attribute float thresholdTime;
    attribute float damping;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleTireCamberAngleState {
    void PxVehicleTireCamberAngleState();
    void setToDefault();
    attribute float camberAngle;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleTireDirectionState {
    void PxVehicleTireDirectionState();
    void setToDefault();
    [Value] attribute PxVec3[] directions;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleTireForce {
    void PxVehicleTireForce();
    void setToDefault();
    [Value] attribute PxVec3[] forces;
    [Value] attribute PxVec3[] torques;
    attribute float aligningMoment;
    attribute float wheelTorque;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleTireForceParams {
    void PxVehicleTireForceParams();
    [Value] PxVehicleTireForceParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid();
    attribute float latStiffX;
    attribute float latStiffY;
    attribute float longStiff;
    attribute float camberStiff;
    attribute float restLoad;
};

[NoDelete]
interface PxVehicleTireForceParamsExt {
    static void setFrictionVsSlip(PxVehicleTireForceParams tireForceParams, unsigned long i, unsigned long j, float value);
    static void setLoadFilter(PxVehicleTireForceParams tireForceParams, unsigned long i, unsigned long j, float value);
};

[Prefix="physx::vehicle2::"]
interface PxVehicleTireGripState {
    void setToDefault();
    attribute float load;
    attribute float friction;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleTireSlipParams {
    void PxVehicleTireSlipParams();
    void setToDefault();
    [Value] PxVehicleTireSlipParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid();
    attribute float minLatSlipDenominator;
    attribute float minPassiveLongSlipDenominator;
    attribute float minActiveLongSlipDenominator;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleTireSlipState {
    void PxVehicleTireSlipState();
    void setToDefault();
    attribute float[] slips;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleTireSpeedState {
    void PxVehicleTireSpeedState();
    void setToDefault();
    attribute float[] speedStates;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleTireStickyParams {
    void PxVehicleTireStickyParams();
    void setToDefault();
    [Value] PxVehicleTireStickyParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid();
    [Value] attribute PxVehicleTireAxisStickyParams[] stickyParams;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleTireStickyState {
    void PxVehicleTireStickyState();
    void setToDefault();
    attribute float[] lowSpeedTime;
    attribute boolean[] activeStatus;
};

[NoDelete]
interface PxVehicleTopLevelFunctions {
    static boolean InitVehicleExtension([Ref] PxFoundation foundation);
    static void CloseVehicleExtension();
    static boolean VehicleComputeSprungMasses(unsigned long nbSprungMasses, [Const, Ref] Vector_PxVec3 sprungMassCoordinates, float totalMass, PxVehicleAxesEnum gravityDirection, [Ref] Vector_PxReal sprungMasses);
    static readonly attribute unsigned long MAX_NB_ENGINE_TORQUE_CURVE_ENTRIES;
};

interface PxVehicleTorqueCurveLookupTable {
    void PxVehicleTorqueCurveLookupTable();
    boolean addPair(float x, float y);
    float interpolate(float x);
    void clear();
    boolean isValid();
};

[Prefix="physx::vehicle2::"]
interface PxVehicleWheelActuationState {
    void PxVehicleWheelActuationState();
    void setToDefault();
    attribute boolean isBrakeApplied;
    attribute boolean isDriveApplied;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleWheelConstraintGroupState {
    void PxVehicleWheelConstraintGroupState();
    void setToDefault();
    unsigned long getNbConstraintGroups();
    unsigned long getNbWheelsInConstraintGroup(unsigned long i);
    unsigned long getWheelInConstraintGroup(unsigned long j, unsigned long i);
    float getMultiplierInConstraintGroup(unsigned long j, unsigned long i);
    attribute unsigned long nbGroups;
    attribute unsigned long[] nbWheelsPerGroup;
    attribute unsigned long[] groupToWheelIds;
    attribute unsigned long[] wheelIdsInGroupOrder;
    attribute float[] wheelMultipliersInGroupOrder;
    attribute unsigned long nbWheelsInGroups;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleWheelLocalPose {
    void PxVehicleWheelLocalPose();
    void setToDefault();
    [Value] attribute PxTransform localPose;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleWheelParams {
    void PxVehicleWheelParams();
    [Value] PxVehicleWheelParams transformAndScale([Const, Ref] PxVehicleFrame srcFrame, [Const, Ref] PxVehicleFrame trgFrame, [Const, Ref] PxVehicleScale srcScale, [Const, Ref] PxVehicleScale trgScale);
    boolean isValid();
    attribute float radius;
    attribute float halfWidth;
    attribute float mass;
    attribute float moi;
    attribute float dampingRate;
};

[Prefix="physx::vehicle2::"]
interface PxVehicleWheelRigidBody1dState {
    void PxVehicleWheelRigidBody1dState();
    void setToDefault();
    attribute float rotationSpeed;
    attribute float correctedRotationSpeed;
    attribute float rotationAngle;
};

interface PxVehicleWheelsPtr {
};

interface SimpleControllerBehaviorCallback {
    unsigned long getShapeBehaviorFlags([Const, Ref] PxShape shape, [Const, Ref] PxActor actor);
    unsigned long getControllerBehaviorFlags([Const, Ref] PxController controller);
    unsigned long getObstacleBehaviorFlags([Const, Ref] PxObstacle obstacle);
};
SimpleControllerBehaviorCallback implements PxControllerBehaviorCallback;

interface SimpleQueryFilterCallback {
    unsigned long simplePreFilter([Const, Ref] PxFilterData filterData, [Const] PxShape shape, [Const] PxRigidActor actor, [Ref] PxHitFlags queryFlags);
    unsigned long simplePostFilter([Const, Ref] PxFilterData filterData, [Const, Ref] PxQueryHit hit);
};
SimpleQueryFilterCallback implements PxQueryFilterCallback;

interface SimpleSimulationEventCallback {
    void onConstraintBreak(PxConstraintInfo constraints, unsigned long count);
    void onWake(PxActorPtr actors, unsigned long count);
    void onSleep(PxActorPtr actors, unsigned long count);
    void onContact([Const, Ref] PxContactPairHeader pairHeader, [Const] PxContactPair pairs, unsigned long nbPairs);
    void onTrigger(PxTriggerPair pairs, unsigned long count);
};
SimpleSimulationEventCallback implements PxSimulationEventCallback;

interface SupportFunctions {
    static PxShape PxActor_getShape([Ref] PxRigidActor actor, long index);
    [Ref] static Vector_PxActorPtr PxScene_getActiveActors(PxScene scene);
};

interface Vector_PxActorPtr {
    void Vector_PxActorPtr();
    void Vector_PxActorPtr(unsigned long size);
    PxActor at(unsigned long index);
    PxActorPtr data();
    unsigned long size();
    void push_back(PxActor value);
    void clear();
};

interface Vector_PxContactPairPoint {
    void Vector_PxContactPairPoint();
    void Vector_PxContactPairPoint(unsigned long size);
    [Ref] PxContactPairPoint at(unsigned long index);
    PxContactPairPoint data();
    unsigned long size();
    void push_back([Ref] PxContactPairPoint value);
    void clear();
};

interface Vector_PxHeightFieldSample {
    void Vector_PxHeightFieldSample();
    void Vector_PxHeightFieldSample(unsigned long size);
    [Ref] PxHeightFieldSample at(unsigned long index);
    PxHeightFieldSample data();
    unsigned long size();
    void push_back([Ref] PxHeightFieldSample value);
    void clear();
};

interface Vector_PxMaterialConst {
    void Vector_PxMaterialConst();
    void Vector_PxMaterialConst(unsigned long size);
    [Const] PxMaterial at(unsigned long index);
    PxMaterialConstPtr data();
    unsigned long size();
    void push_back([Const] PxMaterial value);
    void clear();
};

interface Vector_PxRaycastHit {
    void Vector_PxRaycastHit();
    void Vector_PxRaycastHit(unsigned long size);
    [Ref] PxRaycastHit at(unsigned long index);
    PxRaycastHit data();
    unsigned long size();
    void push_back([Ref] PxRaycastHit value);
    void clear();
};

interface Vector_PxReal {
    void Vector_PxReal();
    void Vector_PxReal(unsigned long size);
    float at(unsigned long index);
    VoidPtr data();
    unsigned long size();
    void push_back(float value);
    void clear();
};

interface Vector_PxSweepHit {
    void Vector_PxSweepHit();
    void Vector_PxSweepHit(unsigned long size);
    [Ref] PxSweepHit at(unsigned long index);
    PxSweepHit data();
    unsigned long size();
    void push_back([Ref] PxSweepHit value);
    void clear();
};

interface Vector_PxU16 {
    void Vector_PxU16();
    void Vector_PxU16(unsigned long size);
    unsigned short at(unsigned long index);
    VoidPtr data();
    unsigned long size();
    void push_back(unsigned short value);
    void clear();
};

interface Vector_PxU32 {
    void Vector_PxU32();
    void Vector_PxU32(unsigned long size);
    unsigned long at(unsigned long index);
    VoidPtr data();
    unsigned long size();
    void push_back(unsigned long value);
    void clear();
};

interface Vector_PxU8 {
    void Vector_PxU8();
    void Vector_PxU8(unsigned long size);
    octet at(unsigned long index);
    VoidPtr data();
    unsigned long size();
    void push_back(octet value);
    void clear();
};

interface Vector_PxVec3 {
    void Vector_PxVec3();
    void Vector_PxVec3(unsigned long size);
    [Ref] PxVec3 at(unsigned long index);
    PxVec3 data();
    unsigned long size();
    void push_back([Ref] PxVec3 value);
    void clear();
};

enum EngineDriveVehicleEnum {
    "EngineDriveVehicleEnum::eDIFFTYPE_FOURWHEELDRIVE",
    "EngineDriveVehicleEnum::eDIFFTYPE_MULTIWHEELDRIVE",
    "EngineDriveVehicleEnum::eDIFFTYPE_TANKDRIVE"
};

enum PxActorFlagEnum {
    "PxActorFlagEnum::eVISUALIZATION",
    "PxActorFlagEnum::eDISABLE_GRAVITY",
    "PxActorFlagEnum::eSEND_SLEEP_NOTIFIES",
    "PxActorFlagEnum::eDISABLE_SIMULATION"
};

enum PxActorTypeEnum {
    "PxActorTypeEnum::eRIGID_STATIC",
    "PxActorTypeEnum::eRIGID_DYNAMIC",
    "PxActorTypeEnum::eARTICULATION_LINK",
    "PxActorTypeEnum::eSOFTBODY",
    "PxActorTypeEnum::eFEMCLOTH",
    "PxActorTypeEnum::ePBD_PARTICLESYSTEM",
    "PxActorTypeEnum::eFLIP_PARTICLESYSTEM",
    "PxActorTypeEnum::eMPM_PARTICLESYSTEM",
    "PxActorTypeEnum::eCUSTOM_PARTICLESYSTEM",
    "PxActorTypeEnum::eHAIRSYSTEM"
};

enum PxActorTypeFlagEnum {
    "PxActorTypeFlagEnum::eRIGID_STATIC",
    "PxActorTypeFlagEnum::eRIGID_DYNAMIC"
};

enum PxArticulationAxisEnum {
    "PxArticulationAxisEnum::eTWIST",
    "PxArticulationAxisEnum::eSWING1",
    "PxArticulationAxisEnum::eSWING2",
    "PxArticulationAxisEnum::eX",
    "PxArticulationAxisEnum::eY",
    "PxArticulationAxisEnum::eZ"
};

enum PxArticulationCacheFlagEnum {
    "PxArticulationCacheFlagEnum::eVELOCITY",
    "PxArticulationCacheFlagEnum::eACCELERATION",
    "PxArticulationCacheFlagEnum::ePOSITION",
    "PxArticulationCacheFlagEnum::eFORCE",
    "PxArticulationCacheFlagEnum::eLINK_VELOCITY",
    "PxArticulationCacheFlagEnum::eLINK_ACCELERATION",
    "PxArticulationCacheFlagEnum::eROOT_TRANSFORM",
    "PxArticulationCacheFlagEnum::eROOT_VELOCITIES",
    "PxArticulationCacheFlagEnum::eSENSOR_FORCES",
    "PxArticulationCacheFlagEnum::eJOINT_SOLVER_FORCES",
    "PxArticulationCacheFlagEnum::eALL"
};

enum PxArticulationDriveTypeEnum {
    "PxArticulationDriveTypeEnum::eFORCE",
    "PxArticulationDriveTypeEnum::eACCELERATION",
    "PxArticulationDriveTypeEnum::eTARGET",
    "PxArticulationDriveTypeEnum::eVELOCITY",
    "PxArticulationDriveTypeEnum::eNONE"
};

enum PxArticulationFlagEnum {
    "PxArticulationFlagEnum::eFIX_BASE",
    "PxArticulationFlagEnum::eDRIVE_LIMITS_ARE_FORCES",
    "PxArticulationFlagEnum::eDISABLE_SELF_COLLISION",
    "PxArticulationFlagEnum::eCOMPUTE_JOINT_FORCES"
};

enum PxArticulationJointTypeEnum {
    "PxArticulationJointTypeEnum::eFIX",
    "PxArticulationJointTypeEnum::ePRISMATIC",
    "PxArticulationJointTypeEnum::eREVOLUTE",
    "PxArticulationJointTypeEnum::eSPHERICAL",
    "PxArticulationJointTypeEnum::eUNDEFINED"
};

enum PxArticulationKinematicFlagEnum {
    "PxArticulationKinematicFlagEnum::ePOSITION",
    "PxArticulationKinematicFlagEnum::eVELOCITY"
};

enum PxArticulationMotionEnum {
    "PxArticulationMotionEnum::eLOCKED",
    "PxArticulationMotionEnum::eLIMITED",
    "PxArticulationMotionEnum::eFREE"
};

enum PxArticulationSensorFlagEnum {
    "PxArticulationSensorFlagEnum::eFORWARD_DYNAMICS_FORCES",
    "PxArticulationSensorFlagEnum::eCONSTRAINT_SOLVER_FORCES",
    "PxArticulationSensorFlagEnum::eWORLD_FRAME"
};

enum PxBVHBuildStrategyEnum {
    "PxBVHBuildStrategyEnum::eFAST",
    "PxBVHBuildStrategyEnum::eDEFAULT",
    "PxBVHBuildStrategyEnum::eSAH"
};

enum PxBaseFlagEnum {
    "PxBaseFlagEnum::eOWNS_MEMORY",
    "PxBaseFlagEnum::eIS_RELEASABLE"
};

enum PxBroadPhaseTypeEnum {
    "PxBroadPhaseTypeEnum::eSAP",
    "PxBroadPhaseTypeEnum::eMBP",
    "PxBroadPhaseTypeEnum::eABP",
    "PxBroadPhaseTypeEnum::ePABP",
    "PxBroadPhaseTypeEnum::eGPU"
};

enum PxCapsuleClimbingModeEnum {
    "PxCapsuleClimbingModeEnum::eEASY",
    "PxCapsuleClimbingModeEnum::eCONSTRAINED"
};

enum PxCombineModeEnum {
    "PxCombineModeEnum::eAVERAGE",
    "PxCombineModeEnum::eMIN",
    "PxCombineModeEnum::eMULTIPLY",
    "PxCombineModeEnum::eMAX"
};

enum PxConstraintFlagEnum {
    "PxConstraintFlagEnum::eBROKEN",
    "PxConstraintFlagEnum::ePROJECT_TO_ACTOR0",
    "PxConstraintFlagEnum::ePROJECT_TO_ACTOR1",
    "PxConstraintFlagEnum::ePROJECTION",
    "PxConstraintFlagEnum::eCOLLISION_ENABLED",
    "PxConstraintFlagEnum::eVISUALIZATION",
    "PxConstraintFlagEnum::eDRIVE_LIMITS_ARE_FORCES",
    "PxConstraintFlagEnum::eIMPROVED_SLERP",
    "PxConstraintFlagEnum::eDISABLE_PREPROCESSING",
    "PxConstraintFlagEnum::eENABLE_EXTENDED_LIMITS",
    "PxConstraintFlagEnum::eGPU_COMPATIBLE"
};

enum PxContactPairFlagEnum {
    "PxContactPairFlagEnum::eREMOVED_SHAPE_0",
    "PxContactPairFlagEnum::eREMOVED_SHAPE_1",
    "PxContactPairFlagEnum::eACTOR_PAIR_HAS_FIRST_TOUCH",
    "PxContactPairFlagEnum::eACTOR_PAIR_LOST_TOUCH",
    "PxContactPairFlagEnum::eINTERNAL_HAS_IMPULSES",
    "PxContactPairFlagEnum::eINTERNAL_CONTACTS_ARE_FLIPPED"
};

enum PxContactPairHeaderFlagEnum {
    "PxContactPairHeaderFlagEnum::eREMOVED_ACTOR_0",
    "PxContactPairHeaderFlagEnum::eREMOVED_ACTOR_1"
};

enum PxControllerBehaviorFlagEnum {
    "PxControllerBehaviorFlagEnum::eCCT_CAN_RIDE_ON_OBJECT",
    "PxControllerBehaviorFlagEnum::eCCT_SLIDE",
    "PxControllerBehaviorFlagEnum::eCCT_USER_DEFINED_RIDE"
};

enum PxControllerCollisionFlagEnum {
    "PxControllerCollisionFlagEnum::eCOLLISION_SIDES",
    "PxControllerCollisionFlagEnum::eCOLLISION_UP",
    "PxControllerCollisionFlagEnum::eCOLLISION_DOWN"
};

enum PxControllerNonWalkableModeEnum {
    "PxControllerNonWalkableModeEnum::ePREVENT_CLIMBING",
    "PxControllerNonWalkableModeEnum::ePREVENT_CLIMBING_AND_FORCE_SLIDING"
};

enum PxControllerShapeTypeEnum {
    "PxControllerShapeTypeEnum::eBOX",
    "PxControllerShapeTypeEnum::eCAPSULE"
};

enum PxConvexFlagEnum {
    "PxConvexFlagEnum::e16_BIT_INDICES",
    "PxConvexFlagEnum::eCOMPUTE_CONVEX",
    "PxConvexFlagEnum::eCHECK_ZERO_AREA_TRIANGLES",
    "PxConvexFlagEnum::eQUANTIZE_INPUT",
    "PxConvexFlagEnum::eDISABLE_MESH_VALIDATION",
    "PxConvexFlagEnum::ePLANE_SHIFTING",
    "PxConvexFlagEnum::eFAST_INERTIA_COMPUTATION",
    "PxConvexFlagEnum::eGPU_COMPATIBLE",
    "PxConvexFlagEnum::eSHIFT_VERTICES"
};

enum PxConvexMeshCookingTypeEnum {
    "PxConvexMeshCookingTypeEnum::eQUICKHULL"
};

enum PxConvexMeshGeometryFlagEnum {
    "PxConvexMeshGeometryFlagEnum::eTIGHT_BOUNDS"
};

enum PxD6AxisEnum {
    "PxD6AxisEnum::eX",
    "PxD6AxisEnum::eY",
    "PxD6AxisEnum::eZ",
    "PxD6AxisEnum::eTWIST",
    "PxD6AxisEnum::eSWING1",
    "PxD6AxisEnum::eSWING2"
};

enum PxD6DriveEnum {
    "PxD6DriveEnum::eX",
    "PxD6DriveEnum::eY",
    "PxD6DriveEnum::eZ",
    "PxD6DriveEnum::eSWING",
    "PxD6DriveEnum::eTWIST",
    "PxD6DriveEnum::eSLERP"
};

enum PxD6JointDriveFlagEnum {
    "PxD6JointDriveFlagEnum::eACCELERATION"
};

enum PxD6MotionEnum {
    "PxD6MotionEnum::eLOCKED",
    "PxD6MotionEnum::eLIMITED",
    "PxD6MotionEnum::eFREE"
};

enum PxDistanceJointFlagEnum {
    "PxDistanceJointFlagEnum::eMAX_DISTANCE_ENABLED",
    "PxDistanceJointFlagEnum::eMIN_DISTANCE_ENABLED",
    "PxDistanceJointFlagEnum::eSPRING_ENABLED"
};

enum PxDynamicTreeSecondaryPrunerEnum {
    "PxDynamicTreeSecondaryPrunerEnum::eNONE",
    "PxDynamicTreeSecondaryPrunerEnum::eBUCKET",
    "PxDynamicTreeSecondaryPrunerEnum::eINCREMENTAL",
    "PxDynamicTreeSecondaryPrunerEnum::eBVH"
};

enum PxErrorCodeEnum {
    "PxErrorCodeEnum::eNO_ERROR",
    "PxErrorCodeEnum::eDEBUG_INFO",
    "PxErrorCodeEnum::eDEBUG_WARNING",
    "PxErrorCodeEnum::eINVALID_PARAMETER",
    "PxErrorCodeEnum::eINVALID_OPERATION",
    "PxErrorCodeEnum::eOUT_OF_MEMORY",
    "PxErrorCodeEnum::eINTERNAL_ERROR",
    "PxErrorCodeEnum::eABORT",
    "PxErrorCodeEnum::ePERF_WARNING",
    "PxErrorCodeEnum::eMASK_ALL"
};

enum PxFilterFlagEnum {
    "PxFilterFlagEnum::eKILL",
    "PxFilterFlagEnum::eSUPPRESS",
    "PxFilterFlagEnum::eCALLBACK",
    "PxFilterFlagEnum::eNOTIFY",
    "PxFilterFlagEnum::eDEFAULT"
};

enum PxFilterObjectFlagEnum {
    "PxFilterObjectFlagEnum::eKINEMATIC",
    "PxFilterObjectFlagEnum::eTRIGGER"
};

enum PxForceModeEnum {
    "PxForceModeEnum::eFORCE",
    "PxForceModeEnum::eIMPULSE",
    "PxForceModeEnum::eVELOCITY_CHANGE",
    "PxForceModeEnum::eACCELERATION"
};

enum PxFrictionTypeEnum {
    "PxFrictionTypeEnum::ePATCH",
    "PxFrictionTypeEnum::eONE_DIRECTIONAL",
    "PxFrictionTypeEnum::eTWO_DIRECTIONAL",
    "PxFrictionTypeEnum::eFRICTION_COUNT"
};

enum PxGeometryTypeEnum {
    "PxGeometryTypeEnum::eSPHERE",
    "PxGeometryTypeEnum::ePLANE",
    "PxGeometryTypeEnum::eCAPSULE",
    "PxGeometryTypeEnum::eBOX",
    "PxGeometryTypeEnum::eCONVEXMESH",
    "PxGeometryTypeEnum::eTRIANGLEMESH",
    "PxGeometryTypeEnum::eHEIGHTFIELD"
};

enum PxHeightFieldFlagEnum {
    "PxHeightFieldFlagEnum::eNO_BOUNDARY_EDGES"
};

enum PxHeightFieldFormatEnum {
    "PxHeightFieldFormatEnum::eS16_TM"
};

enum PxHitFlagEnum {
    "PxHitFlagEnum::ePOSITION",
    "PxHitFlagEnum::eNORMAL",
    "PxHitFlagEnum::eUV",
    "PxHitFlagEnum::eASSUME_NO_INITIAL_OVERLAP",
    "PxHitFlagEnum::eMESH_MULTIPLE",
    "PxHitFlagEnum::eMESH_ANY",
    "PxHitFlagEnum::eMESH_BOTH_SIDES",
    "PxHitFlagEnum::ePRECISE_SWEEP",
    "PxHitFlagEnum::eMTD",
    "PxHitFlagEnum::eFACE_INDEX",
    "PxHitFlagEnum::eDEFAULT",
    "PxHitFlagEnum::eMODIFIABLE_FLAGS"
};

enum PxIDENTITYEnum {
    "PxIDENTITYEnum::PxIdentity"
};

enum PxJointActorIndexEnum {
    "PxJointActorIndexEnum::eACTOR0",
    "PxJointActorIndexEnum::eACTOR1"
};

enum PxMaterialFlagEnum {
    "PxMaterialFlagEnum::eDISABLE_FRICTION",
    "PxMaterialFlagEnum::eDISABLE_STRONG_FRICTION",
    "PxMaterialFlagEnum::eIMPROVED_PATCH_FRICTION"
};

enum PxMeshCookingHintEnum {
    "PxMeshCookingHintEnum::eSIM_PERFORMANCE",
    "PxMeshCookingHintEnum::eCOOKING_PERFORMANCE"
};

enum PxMeshFlagEnum {
    "PxMeshFlagEnum::eFLIPNORMALS",
    "PxMeshFlagEnum::e16_BIT_INDICES"
};

enum PxMeshGeometryFlagEnum {
    "PxMeshGeometryFlagEnum::eDOUBLE_SIDED"
};

enum PxMeshMidPhaseEnum {
    "PxMeshMidPhaseEnum::eBVH33",
    "PxMeshMidPhaseEnum::eBVH34"
};

enum PxMeshPreprocessingFlagEnum {
    "PxMeshPreprocessingFlagEnum::eWELD_VERTICES",
    "PxMeshPreprocessingFlagEnum::eDISABLE_CLEAN_MESH",
    "PxMeshPreprocessingFlagEnum::eDISABLE_ACTIVE_EDGES_PRECOMPUTE",
    "PxMeshPreprocessingFlagEnum::eFORCE_32BIT_INDICES"
};

enum PxPairFilteringModeEnum {
    "PxPairFilteringModeEnum::eKEEP",
    "PxPairFilteringModeEnum::eSUPPRESS",
    "PxPairFilteringModeEnum::eKILL",
    "PxPairFilteringModeEnum::eDEFAULT"
};

enum PxPairFlagEnum {
    "PxPairFlagEnum::eSOLVE_CONTACT",
    "PxPairFlagEnum::eMODIFY_CONTACTS",
    "PxPairFlagEnum::eNOTIFY_TOUCH_FOUND",
    "PxPairFlagEnum::eNOTIFY_TOUCH_PERSISTS",
    "PxPairFlagEnum::eNOTIFY_TOUCH_LOST",
    "PxPairFlagEnum::eNOTIFY_TOUCH_CCD",
    "PxPairFlagEnum::eNOTIFY_THRESHOLD_FORCE_FOUND",
    "PxPairFlagEnum::eNOTIFY_THRESHOLD_FORCE_PERSISTS",
    "PxPairFlagEnum::eNOTIFY_THRESHOLD_FORCE_LOST",
    "PxPairFlagEnum::eNOTIFY_CONTACT_POINTS",
    "PxPairFlagEnum::eDETECT_DISCRETE_CONTACT",
    "PxPairFlagEnum::eDETECT_CCD_CONTACT",
    "PxPairFlagEnum::ePRE_SOLVER_VELOCITY",
    "PxPairFlagEnum::ePOST_SOLVER_VELOCITY",
    "PxPairFlagEnum::eCONTACT_EVENT_POSE",
    "PxPairFlagEnum::eNEXT_FREE",
    "PxPairFlagEnum::eCONTACT_DEFAULT",
    "PxPairFlagEnum::eTRIGGER_DEFAULT"
};

enum PxParticleSolverTypeEnum {
    "PxParticleSolverTypeEnum::ePBD",
    "PxParticleSolverTypeEnum::eFLIP",
    "PxParticleSolverTypeEnum::eMPM",
    "PxParticleSolverTypeEnum::eCUSTOM"
};

enum PxPrismaticJointFlagEnum {
    "PxPrismaticJointFlagEnum::eLIMIT_ENABLED"
};

enum PxPruningStructureTypeEnum {
    "PxPruningStructureTypeEnum::eNONE",
    "PxPruningStructureTypeEnum::eDYNAMIC_AABB_TREE",
    "PxPruningStructureTypeEnum::eSTATIC_AABB_TREE"
};

enum PxQueryFlagEnum {
    "PxQueryFlagEnum::eSTATIC",
    "PxQueryFlagEnum::eDYNAMIC",
    "PxQueryFlagEnum::ePREFILTER",
    "PxQueryFlagEnum::ePOSTFILTER",
    "PxQueryFlagEnum::eANY_HIT",
    "PxQueryFlagEnum::eNO_BLOCK"
};

enum PxRevoluteJointFlagEnum {
    "PxRevoluteJointFlagEnum::eLIMIT_ENABLED",
    "PxRevoluteJointFlagEnum::eDRIVE_ENABLED",
    "PxRevoluteJointFlagEnum::eDRIVE_FREESPIN"
};

enum PxRigidBodyFlagEnum {
    "PxRigidBodyFlagEnum::eKINEMATIC",
    "PxRigidBodyFlagEnum::eUSE_KINEMATIC_TARGET_FOR_SCENE_QUERIES",
    "PxRigidBodyFlagEnum::eENABLE_CCD",
    "PxRigidBodyFlagEnum::eENABLE_CCD_FRICTION",
    "PxRigidBodyFlagEnum::eENABLE_POSE_INTEGRATION_PREVIEW",
    "PxRigidBodyFlagEnum::eENABLE_SPECULATIVE_CCD",
    "PxRigidBodyFlagEnum::eENABLE_CCD_MAX_CONTACT_IMPULSE",
    "PxRigidBodyFlagEnum::eRETAIN_ACCELERATIONS"
};

enum PxRigidDynamicLockFlagEnum {
    "PxRigidDynamicLockFlagEnum::eLOCK_LINEAR_X",
    "PxRigidDynamicLockFlagEnum::eLOCK_LINEAR_Y",
    "PxRigidDynamicLockFlagEnum::eLOCK_LINEAR_Z",
    "PxRigidDynamicLockFlagEnum::eLOCK_ANGULAR_X",
    "PxRigidDynamicLockFlagEnum::eLOCK_ANGULAR_Y",
    "PxRigidDynamicLockFlagEnum::eLOCK_ANGULAR_Z"
};

enum PxSceneFlagEnum {
    "PxSceneFlagEnum::eENABLE_ACTIVE_ACTORS",
    "PxSceneFlagEnum::eENABLE_CCD",
    "PxSceneFlagEnum::eDISABLE_CCD_RESWEEP",
    "PxSceneFlagEnum::eENABLE_PCM",
    "PxSceneFlagEnum::eDISABLE_CONTACT_REPORT_BUFFER_RESIZE",
    "PxSceneFlagEnum::eDISABLE_CONTACT_CACHE",
    "PxSceneFlagEnum::eREQUIRE_RW_LOCK",
    "PxSceneFlagEnum::eENABLE_STABILIZATION",
    "PxSceneFlagEnum::eENABLE_AVERAGE_POINT",
    "PxSceneFlagEnum::eEXCLUDE_KINEMATICS_FROM_ACTIVE_ACTORS",
    "PxSceneFlagEnum::eENABLE_GPU_DYNAMICS",
    "PxSceneFlagEnum::eENABLE_ENHANCED_DETERMINISM",
    "PxSceneFlagEnum::eENABLE_FRICTION_EVERY_ITERATION",
    "PxSceneFlagEnum::eSUPPRESS_READBACK",
    "PxSceneFlagEnum::eFORCE_READBACK",
    "PxSceneFlagEnum::eMUTABLE_FLAGS"
};

enum PxSceneQueryUpdateModeEnum {
    "PxSceneQueryUpdateModeEnum::eBUILD_ENABLED_COMMIT_ENABLED",
    "PxSceneQueryUpdateModeEnum::eBUILD_ENABLED_COMMIT_DISABLED",
    "PxSceneQueryUpdateModeEnum::eBUILD_DISABLED_COMMIT_DISABLED"
};

enum PxShapeFlagEnum {
    "PxShapeFlagEnum::eSIMULATION_SHAPE",
    "PxShapeFlagEnum::eSCENE_QUERY_SHAPE",
    "PxShapeFlagEnum::eTRIGGER_SHAPE",
    "PxShapeFlagEnum::eVISUALIZATION"
};

enum PxSolverTypeEnum {
    "PxSolverTypeEnum::ePGS",
    "PxSolverTypeEnum::eTGS"
};

enum PxSphericalJointFlagEnum {
    "PxSphericalJointFlagEnum::eLIMIT_ENABLED"
};

enum PxTriangleMeshFlagEnum {
    "PxTriangleMeshFlagEnum::e16_BIT_INDICES",
    "PxTriangleMeshFlagEnum::eADJACENCY_INFO"
};

enum PxTriggerPairFlagEnum {
    "PxTriggerPairFlagEnum::eREMOVED_SHAPE_TRIGGER",
    "PxTriggerPairFlagEnum::eREMOVED_SHAPE_OTHER",
    "PxTriggerPairFlagEnum::eNEXT_FREE"
};

enum PxVehicleAxesEnum {
    "PxVehicleAxesEnum::ePosX",
    "PxVehicleAxesEnum::eNegX",
    "PxVehicleAxesEnum::ePosY",
    "PxVehicleAxesEnum::eNegY",
    "PxVehicleAxesEnum::ePosZ",
    "PxVehicleAxesEnum::eNegZ"
};

enum PxVehicleClutchAccuracyModeEnum {
    "PxVehicleClutchAccuracyModeEnum::eESTIMATE",
    "PxVehicleClutchAccuracyModeEnum::eBEST_POSSIBLE"
};

enum PxVehicleCommandNonLinearResponseParamsEnum {
    "PxVehicleCommandNonLinearResponseParamsEnum::eMAX_NB_COMMAND_VALUES"
};

enum PxVehicleCommandValueResponseTableEnum {
    "PxVehicleCommandValueResponseTableEnum::eMAX_NB_SPEED_RESPONSES"
};

enum PxVehicleDirectDriveTransmissionCommandStateEnum {
    "PxVehicleDirectDriveTransmissionCommandStateEnum::eREVERSE",
    "PxVehicleDirectDriveTransmissionCommandStateEnum::eNEUTRAL",
    "PxVehicleDirectDriveTransmissionCommandStateEnum::eFORWARD"
};

enum PxVehicleEngineDriveTransmissionCommandStateEnum {
    "PxVehicleEngineDriveTransmissionCommandStateEnum::eAUTOMATIC_GEAR"
};

enum PxVehicleGearboxParamsEnum {
    "PxVehicleGearboxParamsEnum::eMAX_NB_GEARS"
};

enum PxVehicleLimitsEnum {
    "PxVehicleLimitsEnum::eMAX_NB_WHEELS",
    "PxVehicleLimitsEnum::eMAX_NB_AXLES"
};

enum PxVehiclePhysXActorUpdateModeEnum {
    "PxVehiclePhysXActorUpdateModeEnum::eAPPLY_VELOCITY",
    "PxVehiclePhysXActorUpdateModeEnum::eAPPLY_ACCELERATION"
};

enum PxVehiclePhysXConstraintLimitsEnum {
    "PxVehiclePhysXConstraintLimitsEnum::eNB_DOFS_PER_PXCONSTRAINT",
    "PxVehiclePhysXConstraintLimitsEnum::eNB_DOFS_PER_WHEEL",
    "PxVehiclePhysXConstraintLimitsEnum::eNB_WHEELS_PER_PXCONSTRAINT",
    "PxVehiclePhysXConstraintLimitsEnum::eNB_CONSTRAINTS_PER_VEHICLE"
};

enum PxVehiclePhysXRoadGeometryQueryTypeEnum {
    "PxVehiclePhysXRoadGeometryQueryTypeEnum::eNONE",
    "PxVehiclePhysXRoadGeometryQueryTypeEnum::eRAYCAST",
    "PxVehiclePhysXRoadGeometryQueryTypeEnum::eSWEEP"
};

enum PxVehiclePhysXSuspensionLimitConstraintParamsDirectionSpecifierEnum {
    "PxVehiclePhysXSuspensionLimitConstraintParamsDirectionSpecifierEnum::eSUSPENSION",
    "PxVehiclePhysXSuspensionLimitConstraintParamsDirectionSpecifierEnum::eROAD_GEOMETRY_NORMAL",
    "PxVehiclePhysXSuspensionLimitConstraintParamsDirectionSpecifierEnum::eNONE"
};

enum PxVehicleSimulationContextTypeEnum {
    "PxVehicleSimulationContextTypeEnum::eDEFAULT",
    "PxVehicleSimulationContextTypeEnum::ePHYSX"
};

enum PxVehicleSuspensionJounceCalculationTypeEnum {
    "PxVehicleSuspensionJounceCalculationTypeEnum::eRAYCAST",
    "PxVehicleSuspensionJounceCalculationTypeEnum::eSWEEP"
};

enum PxVehicleTireDirectionModesEnum {
    "PxVehicleTireDirectionModesEnum::eLONGITUDINAL",
    "PxVehicleTireDirectionModesEnum::eLATERAL"
};

enum PxVisualizationParameterEnum {
    "PxVisualizationParameterEnum::eSCALE",
    "PxVisualizationParameterEnum::eWORLD_AXES",
    "PxVisualizationParameterEnum::eBODY_AXES",
    "PxVisualizationParameterEnum::eBODY_MASS_AXES",
    "PxVisualizationParameterEnum::eBODY_LIN_VELOCITY",
    "PxVisualizationParameterEnum::eBODY_ANG_VELOCITY",
    "PxVisualizationParameterEnum::eCONTACT_POINT",
    "PxVisualizationParameterEnum::eCONTACT_NORMAL",
    "PxVisualizationParameterEnum::eCONTACT_ERROR",
    "PxVisualizationParameterEnum::eCONTACT_FORCE",
    "PxVisualizationParameterEnum::eACTOR_AXES",
    "PxVisualizationParameterEnum::eCOLLISION_AABBS",
    "PxVisualizationParameterEnum::eCOLLISION_SHAPES",
    "PxVisualizationParameterEnum::eCOLLISION_AXES",
    "PxVisualizationParameterEnum::eCOLLISION_COMPOUNDS",
    "PxVisualizationParameterEnum::eCOLLISION_FNORMALS",
    "PxVisualizationParameterEnum::eCOLLISION_EDGES",
    "PxVisualizationParameterEnum::eCOLLISION_STATIC",
    "PxVisualizationParameterEnum::eCOLLISION_DYNAMIC",
    "PxVisualizationParameterEnum::eJOINT_LOCAL_FRAMES",
    "PxVisualizationParameterEnum::eJOINT_LIMITS",
    "PxVisualizationParameterEnum::eCULL_BOX",
    "PxVisualizationParameterEnum::eMBP_REGIONS",
    "PxVisualizationParameterEnum::eSIMULATION_MESH",
    "PxVisualizationParameterEnum::eSDF",
    "PxVisualizationParameterEnum::eNUM_VALUES",
    "PxVisualizationParameterEnum::eFORCE_DWORD"
};