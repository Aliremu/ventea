{"version":3,"sources":["webpack://GltfLoader/webpack/bootstrap","webpack://GltfLoader/./loadingmanager.ts","webpack://GltfLoader/./gltf-asset.ts","webpack://GltfLoader/./loaderutils.ts","webpack://GltfLoader/./fileloader.ts","webpack://GltfLoader/./glb-decoder.ts","webpack://GltfLoader/./gltf-loader.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","LoadingManager","[object Object]","this","urlModifier","undefined","onStart","onProgress","onLoad","onError","isLoading","itemsLoaded","itemsTotal","url","fileloader_1","loadingmanager_1","GLTF_COMPONENT_TYPE_ARRAYS","5120","Int8Array","5121","Uint8Array","5122","Int16Array","5123","Uint16Array","5125","Uint32Array","5126","Float32Array","GLTF_ELEMENTS_PER_TYPE","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","GltfAsset","gltf","baseUri","glbData","manager","bufferData","BufferData","imageData","ImageData","index","bufferViews","Error","bufferView","buffer","byteLength","byteOffset","baseBuffer","baseBufferByteOffset","accessors","acc","elementsPerType","type","data","bufferViewData","byteSize","componentType","BYTES_PER_ELEMENT","count","sparse","indices","values","typedArray","indexData","valueData","typedData","j","Promise","all","preFetchAll","asset","bufferCache","loader","FileLoader","responseType","buffers","uri","binaryChunk","resolveURL","load","bufferDataView","map","_","crossOrigin","imageCache","images","image","sourceURI","isObjectURL","blob","Blob","mimeType","URL","createObjectURL","img","Image","resolve","reject","onerror","itemEnd","itemError","onload","revokeObjectURL","src","itemStart","path","test","LoaderUtils","array","TextDecoder","decode","String","fromCharCode","decodeURIComponent","escape","parts","split","length","pop","join","runningRequests","promise","xhr","XMLHttpRequest","open","self","event","response","status","console","warn","statusText","onprogress","withCredentials","overrideMimeType","header","requestHeaders","setRequestHeader","send","loaderutils_1","BINARY_HEADER_MAGIC","BINARY_HEADER_LENGTH","BINARY_CHUNK_TYPES","JSON","BIN","GLTFBinaryData","headerView","DataView","decodeText","getUint32","chunkView","chunkIndex","chunkLength","chunkType","contentArray","json","glb_decoder_1","gltf_asset_1","__export","GltfLoader","extractUrlBase","parse","fileMap","rootFile","rootPath","file","match","replace","fileURL","baseURL","blobURLs","normalizedURL","has","blobURL","push","forEach","content","version"],"mappings":"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","file":"gltf-loader.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","// Adapted from THREE.LoadingManager\n// https://raw.githubusercontent.com/mrdoob/three.js/master/src/loaders/LoadingManager.js\n\nexport type OnStartOnProgressCallback = ((url: string, itemsLoaded: number, itemsTotal: number) => void) | undefined;\n\nexport class LoadingManager {\n    /** URL modifier function for special I/O cases like GLB and `File` (drag-and-drop) */\n    urlModifier: ((url: string) => string) | undefined = undefined;\n    onStart: OnStartOnProgressCallback = undefined;\n    onProgress: OnStartOnProgressCallback = undefined;\n    onLoad: (() => void) | undefined = undefined;\n    onError: ((url: string) => void) | undefined = undefined;\n\n    private isLoading = false;\n    private itemsLoaded = 0;\n    private itemsTotal = 0;\n\n    itemStart(url: string) {\n        this.itemsTotal++;\n        if (!this.isLoading && this.onStart) {\n            this.onStart(url, this.itemsLoaded, this.itemsTotal);\n        }\n        this.isLoading = true;\n    }\n\n    itemEnd(url: string) {\n        this.itemsLoaded++;\n        if (this.onProgress) {\n            this.onProgress(url, this.itemsLoaded, this.itemsTotal);\n        }\n        if (this.itemsLoaded === this.itemsTotal) {\n            this.isLoading = false;\n            if (this.onLoad) {\n                this.onLoad();\n            }\n        }\n    }\n\n    itemError(url: string) {\n        if (this.onError) {\n            this.onError(url);\n        }\n    }\n\n    resolveURL(url: string) {\n        if (this.urlModifier) {\n            return this.urlModifier(url);\n        }\n        return url;\n    }\n}\n","import { FileLoader } from './fileloader';\nimport { GLTFBinaryData } from './glb-decoder';\nimport { GlTf, GlTfId } from './gltf';\nimport { LoadingManager } from './loadingmanager';\n\n/** Spec: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#accessor-element-size */\nexport const GLTF_COMPONENT_TYPE_ARRAYS: { [index: number]: any } = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array,\n};\n\n/** Spec: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#accessor-element-size */\nexport const GLTF_ELEMENTS_PER_TYPE: { [index: string]: number } = {\n    SCALAR: 1,\n    VEC2:   2,\n    VEC3:   3,\n    VEC4:   4,\n    MAT2:   4,\n    MAT3:   9,\n    MAT4:  16,\n};\n\nexport class GltfAsset {\n    /** The JSON part of the asset. */\n    gltf: GlTf;\n    glbData: GLTFBinaryData | undefined;\n    /** Helper for accessing buffer data */\n    bufferData: BufferData;\n    /** Helper for accessing image data */\n    imageData: ImageData;\n\n    constructor(gltf: GlTf, baseUri: string, glbData: GLTFBinaryData | undefined,\n        manager: LoadingManager = new LoadingManager()) {\n\n        this.gltf = gltf;\n        this.glbData = glbData;\n        this.bufferData = new BufferData(this, baseUri, manager);\n        this.imageData = new ImageData(this, baseUri, manager);\n    }\n\n    /**\n     * Fetch the data for a buffer view. Pass in the `bufferView` property of an\n     * `Accessor`.\n     * NOTE: To avoid any unnessary copies, the data is returned as a `Uint8Array` instead of an `ArrayBuffer`.\n     */\n    async bufferViewData(index: GlTfId): Promise<Uint8Array> {\n        if (!this.gltf.bufferViews) {\n            /* istanbul ignore next */\n            throw new Error('No buffer views found.');\n        }\n        const bufferView = this.gltf.bufferViews[index];\n        const bufferData = await this.bufferData.get(bufferView.buffer);\n        const byteLength = bufferView.byteLength || 0;\n        const byteOffset = bufferView.byteOffset || 0;\n\n        // For GLB files, the 'base buffer' is the whole GLB file, including the json part.\n        // Therefore we have to consider bufferData's offset within its buffer it as well.\n        // For non-GLB files it will be 0.\n        const baseBuffer = bufferData.buffer;\n        const baseBufferByteOffset = bufferData.byteOffset;\n\n        return new Uint8Array(baseBuffer, baseBufferByteOffset + byteOffset, byteLength);\n    }\n\n    /**\n     * Fetch the data associated with the accessor. Equivalent to `bufferViewData` for most accessors; special cases:\n     * - `accessor.bufferView` is undefined: create a buffer initialized with zeroes.\n     * - `accessor.sparse` is defined: Copy underlying buffer view and apply values from `sparse`.\n     */\n    async accessorData(index: GlTfId): Promise<Uint8Array> {\n        if (!this.gltf.accessors) {\n            /* istanbul ignore next */\n            throw new Error('No accessors views found.');\n        }\n        const acc = this.gltf.accessors[index];\n        const elementsPerType = GLTF_ELEMENTS_PER_TYPE[acc.type];\n        let data;\n        if (acc.bufferView !== undefined) {\n            data = await this.bufferViewData(acc.bufferView);\n        } else {\n            const byteSize = GLTF_COMPONENT_TYPE_ARRAYS[acc.componentType].BYTES_PER_ELEMENT *\n                elementsPerType *\n                acc.count;\n            data = new Uint8Array(byteSize);\n        }\n\n        if (acc.sparse) {\n            // parse sparse data\n            const {count, indices, values} = acc.sparse;\n            let typedArray = GLTF_COMPONENT_TYPE_ARRAYS[indices.componentType];\n            let bufferViewData = await this.bufferViewData(indices.bufferView);\n            const indexData = new typedArray(bufferViewData.buffer,\n                bufferViewData.byteOffset + (indices.byteOffset || 0), count);\n\n            typedArray = GLTF_COMPONENT_TYPE_ARRAYS[acc.componentType];\n            bufferViewData = await this.bufferViewData(values.bufferView);\n            const valueData = new typedArray((await this.bufferViewData(values.bufferView)).buffer,\n                bufferViewData.byteOffset + (values.byteOffset || 0), count * elementsPerType);\n\n            // copy base data and change it\n            if (acc.bufferView) { // no copy necessary if no bufferView since data was created above\n                data = new Uint8Array(data);\n            }\n\n            const typedData = new GLTF_COMPONENT_TYPE_ARRAYS[acc.componentType](data.buffer);\n            for (let i = 0; i < count; i++) {\n                for (let j = 0; j < elementsPerType; j++) {\n                    typedData[elementsPerType * indexData[i] + j] = valueData[elementsPerType * i + j];\n                }\n            }\n        }\n\n        return data;\n    }\n\n    /** Pre-fetches all buffer and image data. Useful to avoid stalls due to lazy loading. */\n    async preFetchAll(): Promise<void[][]> {\n        return Promise.all([\n            this.bufferData.preFetchAll(),\n            this.imageData.preFetchAll(),\n        ]);\n    }\n}\n\n// tslint:disable:max-classes-per-file\nexport class BufferData {\n    asset: GltfAsset;\n    baseUri: string;\n    manager: LoadingManager;\n    loader: FileLoader;\n\n    private bufferCache: Array<Uint8Array> = [];\n\n    constructor(asset: GltfAsset, baseUri: string, manager: LoadingManager) {\n        this.asset = asset;\n        this.baseUri = baseUri;\n        this.manager = manager;\n        this.loader = new FileLoader(manager);\n        this.loader.responseType = 'arraybuffer';\n    }\n\n    /**\n     * Get the buffer data. Triggers a network request if this buffer resides\n     * in an external .bin file and is accessed for the first time (cached afterwards).\n     * when it's accessed for the first time and `preFetchAll` has not been used.\n     * To avoid any delays, use `preFetchAll` to pre-fetch everything.\n     * NOTE: To avoid any unnessary copies, the data is returned as a `Uint8Array` instead of an `ArrayBuffer`.\n     */\n    async get(index: GlTfId): Promise<Uint8Array> {\n        if (this.bufferCache[index] !== undefined) {\n            return this.bufferCache[index];\n        }\n\n        const gltf = this.asset.gltf;\n        if (!gltf.buffers) {\n            /* istanbul ignore next */\n            throw new Error('No buffers found.');\n        }\n        const buffer = gltf.buffers[index];\n        // If present, GLB container is required to be the first buffer.\n        if (buffer.uri === undefined) {\n            /* istanbul ignore next */\n            if (index !== 0) { throw new Error('GLB container is required to be the first buffer'); }\n            if (this.asset.glbData === undefined) {\n                throw new Error('invalid gltf: buffer has no uri nor is there a GLB buffer');\n            }\n            return this.asset.glbData.binaryChunk;\n        }\n\n        const url = resolveURL(buffer.uri, this.baseUri);\n        const bufferData: ArrayBuffer = await this.loader.load(url);\n        const bufferDataView = new Uint8Array(bufferData);\n        this.bufferCache[index] = bufferDataView;\n        return bufferDataView;\n    }\n\n    /** Pre-fetches all buffer data. */\n    async preFetchAll(): Promise<void[]> {\n        const buffers = this.asset.gltf.buffers;\n        if (!buffers) { return []; }\n        return Promise.all(buffers.map((_, i): any => this.get(i))) as Promise<void[]>;\n    }\n}\n\nexport class ImageData {\n    asset: GltfAsset;\n    baseUri: string;\n    manager: LoadingManager;\n    /** crossorigin value for file and image requests */\n    crossOrigin = 'anonymous';\n\n    private imageCache: Array<HTMLImageElement> = [];\n\n    constructor(asset: GltfAsset, baseUri: string, manager: LoadingManager) {\n        this.asset = asset;\n        this.baseUri = baseUri;\n        this.manager = manager;\n    }\n\n    /**\n     * Get the image data. Triggers a network request if image is in an external file\n     * and is accessed for the first time (cached afterwards). To avoid any delays,\n     * use `preFetchAll` to pre-fetch everything.\n     */\n    async get(index: GlTfId): Promise<HTMLImageElement> {\n        if (this.imageCache[index] !== undefined) {\n            return this.imageCache[index];\n        }\n\n        const gltf = this.asset.gltf;\n        if (!gltf.images) {\n            /* istanbul ignore next */\n            throw new Error('No images found.');\n        }\n        const image = gltf.images[index];\n\n        let sourceURI: string;\n        let isObjectURL = false;\n        if (image.bufferView !== undefined) {\n            // Load binary image data from bufferView, if provided.\n            const bufferView = await this.asset.bufferViewData(image.bufferView);\n            isObjectURL = true;\n            const blob = new Blob([bufferView], { type: image.mimeType });\n            sourceURI = URL.createObjectURL(blob);\n        } else if (image.uri !== undefined ) {\n            sourceURI = this.manager.resolveURL(resolveURL(image.uri, this.baseUri));\n        } else {\n            /* istanbul ignore next */\n            throw new Error('Invalid glTF: image must either have a `uri` or a `bufferView`');\n        }\n\n        const img = new Image();\n        img.crossOrigin = this.crossOrigin;\n\n        const promise: Promise<HTMLImageElement> = new Promise((resolve, reject) => {\n            img.onerror = () => {\n                reject(`Failed to load ${sourceURI}`);\n                this.manager.itemEnd(sourceURI);\n                this.manager.itemError(sourceURI);\n            };\n            img.onload = () => {\n                if (isObjectURL) {\n                    URL.revokeObjectURL(sourceURI);\n                }\n                this.imageCache[index] = img;\n                resolve(img);\n                this.manager.itemEnd(sourceURI);\n            };\n            // TODO!: onprogress?\n            img.src = sourceURI;\n            this.manager.itemStart(sourceURI);\n        });\n\n        return promise;\n    }\n\n    /** Pre-fetches all image data. */\n    async preFetchAll(): Promise<void[]> {\n        const images = this.asset.gltf.images;\n        if (!images) { return []; }\n        return Promise.all(images.map((_, i): any => this.get(i))) as Promise<void[]>;\n    }\n}\n\n// TODO!!: function required in this form?\nexport function resolveURL(url: string, path: string) {\n    // Invalid URL\n    if (typeof url !== 'string' || url === '') { return ''; }\n    // Absolute URL http://,https://,//\n    if (/^(https?:)?\\/\\//i.test(url)) { return url; }\n    // Data URI\n    if (/^data:.*,.*$/i.test(url)) { return url; }\n    // Blob URL\n    if (/^blob:.*$/i.test(url)) { return url; }\n    // Relative URL\n    return path + url;\n}\n","// Based on THREE.LoaderUtils\n// https://github.com/mrdoob/three.js/blob/master/src/loaders/LoaderUtils.js\n\ndeclare var TextDecoder: any;\n\nexport class LoaderUtils {\n    static decodeText(array: ArrayLike<number>): string {\n        /* istanbul ignore next */\n        if (typeof TextDecoder !== 'undefined') {\n            return new TextDecoder().decode(array);\n        }\n\n        // Avoid the String.fromCharCode.apply(null, array) shortcut, which\n        // throws a \"maximum call stack size exceeded\" error for large arrays.\n        let s = '';\n        for (const c of array as Array<number>) {\n            // Implicitly assumes little-endian.\n            s += String.fromCharCode(c);\n        }\n\n        // Merges multi-byte utf-8 characters.\n        return decodeURIComponent(escape(s));\n    }\n\n    static extractUrlBase(url: string) {\n        const parts = url.split('/');\n        if (parts.length === 1) { return './'; }\n        parts.pop();\n        return parts.join('/') + '/';\n    }\n}\n","// Adapted from THEE.FileLoader\n// https://github.com/mrdoob/three.js/blob/master/src/loaders/FileLoader.js\n\nimport { LoadingManager } from './loadingmanager';\n\nexport type ProgressCallback = (xhr: XMLHttpRequest) => void;\nexport type XMLHttpRequestResponse = any;\n\nexport class FileLoader {\n    manager: LoadingManager;\n    path: string | undefined;\n    responseType: XMLHttpRequestResponseType;\n    withCredentials: boolean;\n    mimeType: string;\n    requestHeaders: { [k: string]: string } ;\n\n    private runningRequests: { [url: string]: Promise<XMLHttpRequestResponse>} = {};\n\n    constructor(manager: LoadingManager) {\n        this.manager = manager;\n    }\n    load(url: string, onProgress?: ProgressCallback): Promise<XMLHttpRequestResponse> {\n        if (this.path !== undefined) { url = this.path + url; }\n        url = this.manager.resolveURL(url);\n\n        if (this.runningRequests[url]) {\n            return this.runningRequests[url];\n        }\n\n        const promise = new Promise((resolve, reject) => {\n            // TODO!!: Check for data: URI\n            // (-> Safari can not handle Data URIs through XMLHttpRequest so process manually)\n\n            // NOTE: Not using `fetch` because it doesn't support progress reporting\n            const xhr = new XMLHttpRequest();\n            xhr.open('GET', url, true);\n            const self = this;\n            xhr.onload = function(event: ProgressEvent) {\n                const response = this.response;\n\n                /* istanbul ignore if */\n                if (this.status === 0) {\n                    // Some browsers return HTTP Status 0 when using non-http protocol\n                    // e.g. 'file://' or 'data://'. Handle as success.\n                    console.warn('FileLoader: HTTP Status 0 received.');\n                    resolve(response);\n                    self.manager.itemEnd(url);\n                } else if (this.status === 200) {\n                    resolve(response);\n                    self.manager.itemEnd(url);\n                } else {\n                    reject({\n                        url,\n                        status: this.status,\n                        statusText: xhr.statusText,\n                    });\n\n                    self.manager.itemEnd(url);\n                    self.manager.itemError(url);\n                }\n\n                delete self.runningRequests[url];\n            };\n\n            xhr.onprogress = (xhr: any) => {\n                if (onProgress) {\n                    onProgress(xhr);\n                }\n            };\n\n            /* istanbul ignore next */\n            xhr.onerror = function(event: ErrorEvent) {\n                reject({\n                    url,\n                    status: this.status,\n                    statusText: xhr.statusText,\n                });\n                self.manager.itemEnd(url);\n                self.manager.itemError(url);\n\n                delete self.runningRequests[url];\n            };\n\n            if (this.responseType) { xhr.responseType = this.responseType; }\n            if (this.withCredentials) { xhr.withCredentials = this.withCredentials; }\n            if (this.mimeType && xhr.overrideMimeType) {\n                xhr.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');\n            }\n\n            for (const header in this.requestHeaders) {\n                xhr.setRequestHeader(header, this.requestHeaders[header]);\n            }\n\n            // tslint:disable-next-line:no-null-keyword\n            xhr.send(null);\n            this.manager.itemStart(url);\n        });\n\n        this.runningRequests[url] = promise;\n\n        return promise;\n    }\n\n    setRequestHeader(key: string, value: string) {\n        this.requestHeaders[key] = value;\n        return this;\n    }\n}\n","import { LoaderUtils } from './loaderutils';\n\nexport const BINARY_HEADER_MAGIC = 'glTF';\nconst BINARY_HEADER_LENGTH = 12;\nconst BINARY_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\nexport class GLTFBinaryData {\n    json: string;\n    binaryChunk: Uint8Array;\n    constructor(data: ArrayBuffer) {\n        const headerView = new DataView(data, 0, BINARY_HEADER_LENGTH);\n\n        const header = {\n            magic: LoaderUtils.decodeText(new Uint8Array(data, 0, 4)),\n            version: headerView.getUint32(4, true),\n            length: headerView.getUint32(8, true),\n        };\n\n        if (header.magic !== BINARY_HEADER_MAGIC) {\n            throw new Error('Unsupported glTF-Binary header.');\n        } else if (header.version < 2.0) {\n            throw new Error('Unsupported legacy binary file detected.');\n        }\n\n        const chunkView = new DataView(data, BINARY_HEADER_LENGTH);\n        let chunkIndex = 0;\n        while (chunkIndex < chunkView.byteLength) {\n            const chunkLength = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n\n            const chunkType = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n\n            if (chunkType === BINARY_CHUNK_TYPES.JSON) {\n                const contentArray = new Uint8Array(data, BINARY_HEADER_LENGTH + chunkIndex, chunkLength);\n                this.json = LoaderUtils.decodeText(contentArray);\n\n            } else if (chunkType === BINARY_CHUNK_TYPES.BIN) {\n                const byteOffset = BINARY_HEADER_LENGTH + chunkIndex;\n                this.binaryChunk = new Uint8Array(data, byteOffset, chunkLength);\n            }\n\n            // Clients must ignore chunks with unknown types.\n\n            chunkIndex += chunkLength;\n        }\n\n        if (this.json === null) {\n            throw new Error('glTF-Binary: JSON content not found.');\n        }\n    }\n}\n","// Originally derived from THREE.GLTFLoader\n// https://github.com/mrdoob/three.js/blob/master/examples/js/loaders/GLTFLoader.js\n\nimport { FileLoader } from './fileloader';\nimport { BINARY_HEADER_MAGIC, GLTFBinaryData } from './glb-decoder';\nimport { GltfAsset } from './gltf-asset';\nimport { LoaderUtils } from './loaderutils';\nimport { LoadingManager } from './loadingmanager';\n\n// main library exports\nimport * as gltf from './gltf';\nexport {gltf };\nexport * from './gltf-asset';\nexport * from './loadingmanager';\n\n/** Main class of the library */\nexport class GltfLoader {\n    private manager: LoadingManager;\n\n    /**\n     * Pass in a custom `LoadingManager` for progress reporting.\n     */\n    constructor(manager?: LoadingManager) {\n        this.manager = manager || new LoadingManager();\n    }\n\n    /**\n     * Load glTF from a URL. Only the main file is loaded - external buffer and image files\n     * are loaded lazily when needed. To load all, you can use `GltfAsset.preFetchAll()`\n     */\n    async load(url: string, onProgress?: (xhr: XMLHttpRequest) => void): Promise<GltfAsset> {\n        // TODO!!: test data URI here\n        const path = LoaderUtils.extractUrlBase(url);\n        // TODO!: allow changing loader options(headers etc.)?\n        const loader = new FileLoader(this.manager);\n        loader.responseType = 'arraybuffer';\n        const data = await loader.load(url, onProgress);\n        return await this.parse(data, path);\n    }\n\n    /**\n     * Load from `File`s you might get from a file input or via drag-and-drop.\n     * `fileMap` is expected to map from a full file path (including directories if present).\n     * This matches the format provided by [simple-dropzone](https://www.npmjs.com/package/simple-dropzone).\n     * If you don't need support for directories/zip files, you can use `File.name` as the key.\n     *\n     * Note that `preFetchAll` is called on the result GltfAsset before returning it so that\n     * the uploaded files can be garbage-collected immediately.\n     */\n    /* istanbul ignore next: relies too much on browser APIs; covered by drag-and-drop example */\n    async loadFromFiles(fileMap: Map<string, File>): Promise<GltfAsset> {\n        // code derived from three-gltf-viewer\n        let rootFile;\n        let rootPath: string;\n        for (const [path, file] of fileMap) {\n            if (file.name.match(/\\.(gltf|glb)$/)) {\n                rootFile = file;\n                rootPath = path.replace(file.name, '');\n            }\n        }\n\n        if (!rootFile) {\n          throw new Error('No .gltf or .glb asset found.');\n        }\n\n        const fileURL = typeof rootFile === 'string'\n            ? rootFile\n            : URL.createObjectURL(rootFile);\n\n        // Intercept and override relative URLs.\n        const baseURL = LoaderUtils.extractUrlBase(fileURL); // TODO!!: does this make sense here?\n        const blobURLs: string[] = [];\n        this.manager.urlModifier = (url: string) => {\n            const normalizedURL = rootPath + url\n            .replace(baseURL, '')\n            .replace(/^(\\.?\\/)/, '');\n\n            if (fileMap.has(normalizedURL)) {\n                const blob = fileMap.get(normalizedURL);\n                const blobURL = URL.createObjectURL(blob);\n                blobURLs.push(blobURL);\n                return blobURL;\n            }\n\n            return url;\n        };\n\n        const asset = await this.load(fileURL);\n        await asset.preFetchAll(); // fetch all so the object urls can be released below\n\n        URL.revokeObjectURL(fileURL);\n        blobURLs.forEach(URL.revokeObjectURL);\n\n        return asset;\n    }\n\n    private async parse(data: ArrayBuffer, path: string): Promise<GltfAsset> {\n        let content: string;\n        // tslint:disable-next-line:no-unnecessary-initializer\n        let glbData: GLTFBinaryData | undefined = undefined;\n        if (typeof data === 'string') {\n            content = data;\n        } else {\n            const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n            if (magic === BINARY_HEADER_MAGIC) {\n                glbData = new GLTFBinaryData(data);\n                content = glbData.json;\n            } else {\n                content = LoaderUtils.decodeText(new Uint8Array(data));\n            }\n        }\n\n        const json = JSON.parse(content);\n\n        if (json.asset === undefined || json.asset.version[ 0 ] < 2) {\n            throw new Error('Unsupported asset. glTF versions >=2.0 are supported.');\n        }\n\n        return new GltfAsset(json, path, glbData, this.manager);\n    }\n}\n"],"sourceRoot":""}